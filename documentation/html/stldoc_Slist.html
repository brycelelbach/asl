<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: Slist</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="http://sourceforge.net/adobe/">Open @ Adobe</a><br/>
        <a href="http://opensource.adobe.com/">Adobe Open Source</a><br/>
        <a href="http://labs.adobe.com/">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.7.2 -->
<div class="header">
  <div class="headertitle">
<h1>Slist </h1>  </div>
</div>
<div class="contents">
<table  cellpadding="0" cellspacing="0" width="100%" border="0">
<tr>
<td align="left"><div align="center">
<img src="containers.gif" alt="containers.gif"/>
</div>
 </td><td width="100%"></td><td align="right"><div align="center">
<img src="type.gif" alt="type.gif"/>
</div>
  </td></tr>
<tr>
<td align="left" valign="top"><b>Category</b>: containers </td><td width="100%"></td><td align="right" valign="top"><b>Component type</b>: type  </td></tr>
</table>
<h2><a class="anchor" id="Description"></a>
Description</h2>
<p>An <code>slist</code> is a singly linked list: a list where each element is linked to the next element, but not to the previous element. <a href="#1">[1]</a> That is, it is a <a class="el" href="stldoc_Sequence.html">Sequence</a> that supports forward but not backward traversal, and (amortized) constant time insertion and removal of elements. <code>Slist</code>s, like <code><a class="el" href="stldoc_List.html">List</a></code>s, have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed. The ordering of iterators may be changed (that is, <code>slist&lt;T&gt;iterator</code> might have a different predecessor or successor after a list operation than it did before), but the iterators themselves will not be invalidated or made to point to different elements unless that invalidation or mutation is explicit. <a href="#2">[2]</a> </p>
<p>The main difference between <code>slist</code> and <code><a class="el" href="stldoc_List.html">List</a></code> is that <code><a class="el" href="stldoc_List.html">List</a></code>'s iterators are <a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a>, while <code>slist</code>'s iterators are <a class="el" href="stldoc_ForwardIterator.html">ForwardIterator</a>. This means that <code>slist</code> is less versatile than <code><a class="el" href="stldoc_List.html">List</a></code>; frequently, however, <a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a> are unnecessary. You should usually use <code>slist</code> unless you actually need the extra functionality of <code><a class="el" href="stldoc_List.html">List</a></code>, because singly linked lists are smaller and faster than double linked lists. </p>
<p><b>Important performance note</b>: like every other <a class="el" href="stldoc_Sequence.html">Sequence</a>, <code>slist</code> defines the member functions <code>insert</code> and <code>erase</code>. Using these member functions carelessly, however, can result in disastrously slow programs. The problem is that <code>insert</code>'s first argument is an iterator <code>pos</code>, and that it inserts the new element(s) <em>before</em> <code>pos</code>. This means that <code>insert</code> must find the iterator just before <code>pos</code>; this is a constant-time operation for <code><a class="el" href="stldoc_List.html">List</a></code>, since <code><a class="el" href="stldoc_List.html">List</a></code> has bidirectional iterators, but for <code>slist</code> it must find that iterator by traversing the list from the beginning up to <code>pos</code>. In other words: <code>insert</code> and <code>erase</code> are slow operations anywhere but near the beginning of the <code>slist</code>. </p>
<p><code>Slist</code> provides the member functions <code>insert_after</code> and <code>erase_after</code>, which are constant time operations: you should always use <code>insert_after</code> and <code>erase_after</code> whenever possible. If you find that <code>insert_after</code> and <code>erase_after</code> aren't adequate for your needs, and that you often need to use <code>insert</code> and <code>erase</code> in the middle of the list, then you should probably use <code><a class="el" href="stldoc_List.html">List</a></code> instead of <code>slist</code>. </p>
<h2><a class="anchor" id="Definition"></a>
Definition</h2>
<p>Defined in the header <a href="slist">slist</a>, and in the backward-compatibility header <a href="slist.h">slist.h</a>. The <code>slist</code> class, and the <a href="slist">slist</a> header, are an SGI extension; they are not part of the C++ standard. </p>
<h2><a class="anchor" id="Example"></a>
Example</h2>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main() {
  slist&lt;int&gt; L;
  L.push_front(0);
  L.push_front(1);
  L.insert_after(L.begin(), 2);
  <a class="code" href="group__copy.html#ga213e2d8058f7aab229cb3b6099634256" title="copy implementation">copy</a>(L.begin(), L.end(),        <span class="comment">// The output is 1 2 0</span>
       ostream_iterator&lt;int&gt;(cout, <span class="stringliteral">&quot; &quot;</span>));
  cout &lt;&lt; endl;

  slist&lt;int&gt;::iterator back = L.previous(L.end());
  back = L.insert_after(back, 3); 
  back = L.insert_after(back, 4);
  back = L.insert_after(back, 5);
  <a class="code" href="group__copy.html#ga213e2d8058f7aab229cb3b6099634256" title="copy implementation">copy</a>(L.begin(), L.end(),        <span class="comment">// The output is 1 2 0 3 4 5</span>
       ostream_iterator&lt;int&gt;(cout, <span class="stringliteral">&quot; &quot;</span>));
  cout &lt;&lt; endl;
}
</pre></div> <h2><a class="anchor" id="Template_parameters"></a>
Template parameters</h2>
<table  border="1" cellpadding="3" cellspacing="3">
<tr>
<th>Parameter  </th><th>Description  </th><th>Default   </th></tr>
<tr>
<td valign="top"><code>T</code>  </td><td valign="top">The <code>slist</code>'s value type: the type of object that is stored in the list.  </td><td valign="top">&#160;   </td></tr>
<tr>
<td valign="top"><code>Alloc</code>  </td><td valign="top">The <code>slist</code>'s allocator, used for all internal memory management.  </td><td valign="top"><code><a class="el" href="stldoc_Allocators.html">Allocators</a></code>   </td></tr>
</table>
<h2><a class="anchor" id="Model_of"></a>
Model of</h2>
<p><a class="el" href="group__stldoc__FrontInsertionSequence.html">FrontInsertionSequence</a> </p>
<h2><a class="anchor" id="Type_requirements"></a>
Type requirements</h2>
<p>None, except for those imposed by the requirements of <a class="el" href="group__stldoc__FrontInsertionSequence.html">FrontInsertionSequence</a>. </p>
<h2><a class="anchor" id="Public_base_classes"></a>
Public base classes</h2>
<p>None. </p>
<h2><a class="anchor" id="Members"></a>
Members</h2>
<table  border="1" cellpadding="3" cellspacing="3">
<tr>
<th>Member  </th><th>Where defined  </th><th>Description   </th></tr>
<tr>
<td valign="top"><code>value_type</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">The type of object, <code>T</code>, stored in the <code>slist</code>.   </td></tr>
<tr>
<td valign="top"><code>pointer</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Pointer to <code>T</code>.   </td></tr>
<tr>
<td valign="top"><code>reference</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Reference to <code>T</code>   </td></tr>
<tr>
<td valign="top"><code>const_reference</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Const reference to <code>T</code>   </td></tr>
<tr>
<td valign="top"><code>size_type</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">An unsigned integral type.   </td></tr>
<tr>
<td valign="top"><code>difference_type</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">A signed integral type.   </td></tr>
<tr>
<td valign="top"><code>iterator</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Iterator used to iterate through an <code>slist</code>.   </td></tr>
<tr>
<td valign="top"><code>const_iterator</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Const iterator used to iterate through an <code>slist</code>.   </td></tr>
<tr>
<td valign="top"><code>iterator begin()</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Returns an <code>iterator</code> pointing to the beginning of the <code>slist</code>.   </td></tr>
<tr>
<td valign="top"><code>iterator end()</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Returns an <code>iterator</code> pointing to the end of the <code>slist</code>.   </td></tr>
<tr>
<td valign="top"><code>const_iterator begin() const</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Returns a <code>const_iterator</code> pointing to the beginning of the <code>slist</code>.   </td></tr>
<tr>
<td valign="top"><code>const_iterator end() const</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Returns a <code>const_iterator</code> pointing to the end of the <code>slist</code>.   </td></tr>
<tr>
<td valign="top"><code>size_type size() const</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Returns the size of the <code>slist</code>. Note: you should not assume that this function is constant time. It is permitted to be <em>O(N</em>), where <em>N</em> is the number of elements in the <code>slist</code>. If you wish to test whether an <code>slist</code> is empty, you should write <code>L.empty()</code> rather than <code>L.size() == 0</code>.   </td></tr>
<tr>
<td valign="top"><code>size_type max_size() const</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Returns the largest possible size of the <code>slist</code>.   </td></tr>
<tr>
<td valign="top"><code>bool empty() const</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top"><code>true</code> if the <code>slist</code>'s size is <code>0</code>.   </td></tr>
<tr>
<td valign="top"><code>slist()</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Creates an empty slist.   </td></tr>
<tr>
<td valign="top"><code>slist(size_type n)</code>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Creates an <code>slist</code> with <code>n</code> elements, each of which is a copy of <code>T()</code>.   </td></tr>
<tr>
<td valign="top"><code>slist(size_type n, const T&amp; t)</code>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Creates an slist with <code>n</code> copies of <code>t</code>.   </td></tr>
<tr>
<td valign="top"><code>slist(const slist&amp;)</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">The copy constructor.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
slist(InputIterator f, InputIterator l) 
</pre></div> <a href="#3">[3]</a>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Creates an <code>slist</code> with a copy of a range.   </td></tr>
<tr>
<td valign="top"><code>~slist()</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">The destructor.   </td></tr>
<tr>
<td valign="top"><code>slist&amp; operator=(const slist&amp;)</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">The assignment operator   </td></tr>
<tr>
<td valign="top"><code>void swap(slist&amp;)</code>  </td><td valign="top"><a class="el" href="stldoc_Container.html">Container</a>  </td><td valign="top">Swaps the contents of two slists.   </td></tr>
<tr>
<td valign="top"><code>reference front()</code>  </td><td valign="top"><a class="el" href="group__stldoc__FrontInsertionSequence.html">FrontInsertionSequence</a>  </td><td valign="top">Returns the first element.   </td></tr>
<tr>
<td valign="top"><code>const_reference front() const</code>  </td><td valign="top"><a class="el" href="group__stldoc__FrontInsertionSequence.html">FrontInsertionSequence</a>  </td><td valign="top">Returns the first element.   </td></tr>
<tr>
<td valign="top"><code>void push_front(const T&amp;)</code>  </td><td valign="top"><a class="el" href="group__stldoc__FrontInsertionSequence.html">FrontInsertionSequence</a>  </td><td valign="top">Inserts a new element at the beginning.   </td></tr>
<tr>
<td valign="top"><code>void pop_front()</code>  </td><td valign="top"><a class="el" href="group__stldoc__FrontInsertionSequence.html">FrontInsertionSequence</a>  </td><td valign="top">Removes the first element.   </td></tr>
<tr>
<td valign="top"><code>iterator previous(iterator pos)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below   </td></tr>
<tr>
<td valign="top"><code>const_iterator previous(const_iterator pos)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below   </td></tr>
<tr>
<td valign="top"><code>iterator insert(iterator pos, const T&amp; x)</code>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Inserts <code>x</code> before <code>pos</code>.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;
<span class="keywordtype">void</span> <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(iterator pos, InputIterator f, InputIterator l)
</pre></div> <a href="#3">[3]</a>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Inserts the range <code>[first, last)</code> before <code>pos</code>.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(iterator pos,
            size_type n, <span class="keyword">const</span> value_type&amp; x)
</pre></div>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Inserts <code>n</code> copies of <code>x</code> before <code>pos</code>.   </td></tr>
<tr>
<td valign="top"><code>iterator erase(iterator pos)</code>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Erases the element at position <code>pos</code>.   </td></tr>
<tr>
<td valign="top"><code>iterator erase(iterator first, iterator last)</code>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Erases the range <code>[first, last)</code>   </td></tr>
<tr>
<td valign="top"><code>void <a class="el" href="group__sequence__view.html#gae86d3d95373ce0d9f1d92c9f62b58d14" title="SequenceView concept requirement.">clear()</a></code>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Erases all of the elements.   </td></tr>
<tr>
<td valign="top"><code>void resize(n, t = T())</code>  </td><td valign="top"><a class="el" href="stldoc_Sequence.html">Sequence</a>  </td><td valign="top">Inserts or erases elements at the end such that the size becomes <code>n</code>.   </td></tr>
<tr>
<td valign="top"><code>iterator insert_after(iterator pos)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>iterator insert_after(iterator pos, const value_type&amp; x)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;
<span class="keywordtype">void</span> insert_after(iterator pos,
                  InputIterator f, InputIterator l)
</pre></div>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> insert_after(iterator pos, 
                  size_type n, <span class="keyword">const</span> value_type&amp; x)
</pre></div>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>iterator erase_after(iterator pos)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>iterator erase_after(iterator before_first, iterator last)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>void splice(iterator position, slist&amp; L)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>void splice(iterator position, slist&amp; L, iterator i)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>void splice(iterator position, slist&amp; L, iterator f, iterator l)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>void splice_after(iterator pos, iterator prev)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> splice_after(iterator pos, 
                  iterator before_first, 
                  iterator before_last)
</pre></div>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>void remove(const T&amp; value)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>void <a class="el" href="group__unique.html#gafe94d5d87fa1d4cf2a0fade5009749b5" title="unique implementation">unique()</a></code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>void merge(slist&amp; L)</code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><code>void <a class="el" href="group__sort.html#ga4e8798cfae776b33d57d9322d2ce7f79" title="sort implementation">sort()</a></code>  </td><td valign="top"><code>slist</code>  </td><td valign="top">See below.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="classadobe_1_1circular__queue.html#ae028dd8c91b91e048b3ced7efe56acc6">operator==</a>(<span class="keyword">const</span> slist&amp;, 
                <span class="keyword">const</span> slist&amp;)
</pre></div>  </td><td valign="top"><a class="el" href="stldoc_ForwardContainer.html">ForwardContainer</a>  </td><td valign="top">Tests two slists for equality. This is a global function, not a member function.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="macintosh__events_8hpp.html#ac1dc26b7ab0c84ab816f6c2ffcf54e24">operator&lt;</a>(<span class="keyword">const</span> slist&amp;, 
               <span class="keyword">const</span> slist&amp;)
</pre></div>  </td><td valign="top"><a class="el" href="stldoc_ForwardContainer.html">ForwardContainer</a>  </td><td valign="top">Lexicographical comparison. This is a global function, not a member function.   </td></tr>
</table>
<h2><a class="anchor" id="New_members"></a>
New members</h2>
<p>These members are not defined in the <a class="el" href="group__stldoc__FrontInsertionSequence.html">FrontInsertionSequence</a> requirements, but are specific to <code>slist</code>: </p>
<table  border="1" cellpadding="3" cellspacing="3">
<tr>
<th>Function  </th><th>Description   </th></tr>
<tr>
<td valign="top"><code>iterator previous(iterator pos)</code>  </td><td valign="top"><code>pos</code> must be a valid iterator in <code>*this</code>. The return value is an iterator <code>prev</code> such that <code>++prev == pos</code>. Complexity: linear in the number of iterators in the range <code>[begin(), pos)</code>.   </td></tr>
<tr>
<td valign="top"><code>const_iterator previous(const_iterator pos)</code>  </td><td valign="top"><code>pos</code> must be a valid iterator in <code>*this</code>. The return value is an iterator <code>prev</code> such that <code>++prev == pos</code>. Complexity: linear in the number of iterators in the range <code>[begin(), pos)</code>.   </td></tr>
<tr>
<td valign="top"><code>iterator insert_after(iterator pos)</code>  </td><td valign="top"><code>pos</code> must be a dereferenceable iterator in <code>*this</code>. (That is, <code>pos</code> may not be <code>end()</code>.) Inserts a copy of <code>T()</code> immediately <em>following</em> <code>pos</code>. The return value is an iterator that points to the new element. Complexity: constant time.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment">iterator insert_after(iterator pos,
                      <span class="keyword">const</span> value_type&amp; x)
</pre></div>  </td><td valign="top"><code>pos</code> must be a dereferenceable iterator in <code>*this</code>. (That is, <code>pos</code> may not be <code>end()</code>.) Inserts a copy of <code>x</code> immediately <em>following</em> <code>pos</code>. The return value is an iterator that points to the new element. Complexity: constant time.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;
<span class="keywordtype">void</span> insert_after(iterator pos,
                  InputIterator f, InputIterator l)
</pre></div>  </td><td valign="top">Inserts elements from the range <code>[f, l)</code> immediately <em>following</em> <code>pos</code>. Complexity: linear in <code>last - first</code>.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> insert_after(iterator pos, 
                  size_type n, <span class="keyword">const</span> value_type&amp; x)
</pre></div>  </td><td valign="top">Inserts <code>n</code> copies of <code>x</code> immediately <em>following</em> <code>pos</code>. Complexity: linear in <code>n</code>.   </td></tr>
<tr>
<td valign="top"><code>iterator erase_after(iterator pos)</code>  </td><td valign="top">Erases the element pointed to by the iterator <em>following</em> <code>pos</code>. Complexity: constant time.   </td></tr>
<tr>
<td valign="top"><code>iterator erase_after(iterator before_first, iterator last)</code>  </td><td valign="top">Erases all elements in the range <code>[before_first + 1, last)</code>. Complexity: linear in <code>last - (before_first + 1)</code>.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> splice(iterator position, 
            slist&lt;T, Alloc&gt;&amp; x);
</pre></div>  </td><td valign="top"><code>position</code> must be a valid iterator in <code>*this</code>, and <code>x</code> must be an slist that is distinct from <code>*this</code>. (That is, it is required that <code>&amp;x != this</code>.) All of the elements of <code>x</code> are inserted before <code>position</code> and removed from <code>x</code>. All iterators remain valid, including iterators that point to elements of <code>x</code>. <a href="#4">[4]</a> Complexity: proportional to <code>c1 (position - begin()) + c2(x.size())</code>, where <code>c1</code> and <code>c2</code> are unknown constants.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> splice(iterator position, 
            slist&lt;T, Alloc&gt;&amp; x,
            iterator i);
</pre></div>  </td><td valign="top"><code>position</code> must be a valid iterator in <code>*this</code>, and <code>i</code> must be a dereferenceable iterator in <code>x</code>. <code>Splice</code> moves the element pointed to by <code>i</code> from <code>x</code> to <code>*this</code>, inserting it before <code>position</code>. All iterators remain valid, including iterators that point to elements of <code>x</code>. <a href="#4">[4]</a> If <code>position == i</code> or <code>position == ++i</code>, this function is a null operation. Complexity: proportional to <code>c1 (position - begin()) + c2 (i - x.begin())</code>, where <code>c1</code> and <code>c2</code> are unknown constants.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> splice(iterator position, 
            slist&lt;T, Alloc&gt;&amp; x,
            iterator f, iterator l);
</pre></div>  </td><td valign="top"><code>position</code> must be a valid iterator in <code>*this</code>, and <code>[first, last)</code> must be a valid range in <code>x</code>. <code>position</code> may not be an iterator in the range <code>[first, last)</code>. <code>Splice</code> moves the elements in <code>[first, last)</code> from <code>x</code> to <code>*this</code>, inserting them before <code>position</code>. All iterators remain valid, including iterators that point to elements of <code>x</code>. <a href="#4">[4]</a> Complexity: proportional to <code>c1 (position - begin()) + c2 (f - x.begin()) + c3 (l - f)</code>, where <code>c1</code>, <code>c2</code>, and <code>c3</code> are unknown constants.   </td></tr>
<tr>
<td valign="top"><code>void remove(const T&amp; val);</code>  </td><td valign="top">Removes all elements that compare equal to <code>val</code>. The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly <code><a class="el" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size()</a></code> comparisons for equality.   </td></tr>
<tr>
<td valign="top"><code>void splice_after(iterator pos, iterator prev)</code>  </td><td valign="top"><code>pos</code> must be a dereferenceable iterator in <code>*this</code>, and <code>prev</code> must be a dereferenceable iterator either in <code>*this</code> or in some other <code>slist</code>. (Note: "dereferenceable iterator" implies that neither <code>pos</code> nor <code>prev</code> may be an off-the-end iterator.) Moves the element <em>following</em> <code>prev</code> to <code>*this</code>, inserting it immediately <em>after</em> <code>pos</code>. Complexity: constant time.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> splice_after(iterator pos, 
                  iterator before_first, 
                  iterator before_last)
</pre></div>  </td><td valign="top"><code>pos</code> must be a dereferenceable iterator in <code>*this</code>, and <code>before_first</code> and <code>before_last</code> must be dereferenceable iterators either in <code>*this</code> or in some other <code>slist</code>. (Note: "dereferenceable iterator" implies that none of these iterators may be off-the-end iterators.) Moves the elements in the range <code>[before_first + 1, before_last + 1)</code> to <code>*this</code>, inserting them immediately <em>after</em> <code>pos</code>. Complexity: constant time.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Predicate&gt; 
<span class="keywordtype">void</span> <a class="code" href="group__remove.html#gadfe47898a2648b0ff66d8bb500b6e373" title="remove implementation">remove_if</a>(Predicate p); 
</pre></div> <a href="#5">[5]</a>  </td><td valign="top">Removes all elements <code>*i</code> such that <code>p(*i)</code> is true. The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly <code><a class="el" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size()</a></code> applications of <code>p</code>.   </td></tr>
<tr>
<td valign="top"><code>void <a class="el" href="group__unique.html#gafe94d5d87fa1d4cf2a0fade5009749b5" title="unique implementation">unique()</a>;</code>  </td><td valign="top">Removes all but the first element in every consecutive group of equal elements. The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly <code><a class="el" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size()</a> - 1</code> comparisons for equality.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BinaryPredicate&gt;
<span class="keywordtype">void</span> <a class="code" href="group__unique.html#gafe94d5d87fa1d4cf2a0fade5009749b5" title="unique implementation">unique</a>(BinaryPredicate p); 
</pre></div> <a href="#5">[5]</a>  </td><td valign="top">Removes all but the first element in every consecutive group of equivalent elements, where two elements <code>*i</code> and <code>*j</code> are considered equivalent if <code>p(*i, *j)</code> is true. The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly <code><a class="el" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size()</a> - 1</code> comparisons for equality.   </td></tr>
<tr>
<td valign="top"><code>void merge(slist&lt;T, Alloc&gt;&amp; x);</code>  </td><td valign="top">Both <code>*this</code> and <code>x</code> must be sorted according to <code>operator&lt;</code>, and they must be distinct. (That is, it is required that <code>&amp;x != this</code>.) This function removes all of <code>x</code>'s elements and inserts them in order into <code>*this</code>. The merge is stable; that is, if an element from <code>*this</code> is equivalent to one from <code>x</code>, then the element from <code>*this</code> will precede the one from <code>x</code>. All iterators to elements in <code>*this</code> and <code>x</code> remain valid. This function is linear time: it performs at most <code><a class="el" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size()</a> + x.size() - 1</code> comparisons.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BinaryPredicate&gt;
<span class="keywordtype">void</span> <a class="code" href="group__merge.html#ga1a719f3324ae0dfc25f991e8d767096e" title="merge implementation">merge</a>(slist&lt;T, Alloc&gt;&amp; x, 
           BinaryPredicate Comp); 
</pre></div> <a href="#5">[5]</a>  </td><td valign="top"><code>Comp</code> must be a comparison function that induces a strict weak ordering (as defined in the <a class="el" href="stldoc_LessThanComparable.html">LessThanComparable</a> requirements) on objects of type <code>T</code>, and both <code>*this</code> and <code>x</code> must be sorted according to that ordering. The slists <code>x</code> and <code>*this</code> must be distinct. (That is, it is required that <code>&amp;x != this</code>.) This function removes all of <code>x</code>'s elements and inserts them in order into <code>*this</code>. The merge is stable; that is, if an element from <code>*this</code> is equivalent to one from <code>x</code>, then the element from <code>*this</code> will precede the one from <code>x</code>. All iterators to elements in <code>*this</code> and <code>x</code> remain valid. This function is linear time: it performs at most <code><a class="el" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size()</a> + x.size() - 1</code> applications of <code>Comp</code>.   </td></tr>
<tr>
<td valign="top"><code>void <a class="el" href="group__reverse.html#ga78a6855b85b846ac09dabd77012080b8" title="reverse implementation">reverse()</a>;</code>  </td><td valign="top">Reverses the order of elements in the slist. All iterators remain valid and continue to point to the same elements. <a href="#6">[6]</a> This function is linear time.   </td></tr>
<tr>
<td valign="top"><code>void <a class="el" href="group__sort.html#ga4e8798cfae776b33d57d9322d2ce7f79" title="sort implementation">sort()</a>;</code>  </td><td valign="top">Sorts <code>*this</code> according to <code>operator&lt;</code>. The sort is stable, that is, the relative order of equivalent elements is preserved. All iterators remain valid and continue to point to the same elements. <a href="#7">[7]</a> The number of comparisons is approximately <code>N log N</code>, where <code>N</code> is the <code>slist</code>'s size.   </td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BinaryPredicate&gt;
<span class="keywordtype">void</span> <a class="code" href="group__sort.html#ga4e8798cfae776b33d57d9322d2ce7f79" title="sort implementation">sort</a>(BinaryPredicate comp); 
</pre></div> <a href="#5">[5]</a>  </td><td valign="top"><code>Comp</code> must be a comparison function that induces a strict weak ordering (as defined in the <a class="el" href="stldoc_LessThanComparable.html">LessThanComparable</a> requirements) on objects of type <code>T</code>. This function sorts the slist <code>*this</code> according to <code>Comp</code>. The sort is stable, that is, the relative order of equivalent elements is preserved. All iterators remain valid and continue to point to the same elements. <a href="#7">[7]</a> The number of comparisons is approximately <code>N log N</code>, where <code>N</code> is the <code>slist</code>'s size.   </td></tr>
</table>
<h2><a class="anchor" id="Notes"></a>
Notes</h2>
<p><a class="anchor" id="1"></a>[1] The lists in such languages as Common Lisp, Scheme, and ML are singly linked lists. In some programming languages, almost all data structures are represented as singly linked lists. </p>
<p><a class="anchor" id="2"></a>[2] A comparison with <code><a class="el" href="stldoc_Vector.html">Vector</a></code> is instructive. Suppose that <code>i</code> is a valid <code><a class="el" href="stldoc_Vector.html">Vector</a>&lt;T&gt;iterator</code>. If an element is inserted or removed in a position that precedes <code>i</code>, then this operation will either result in <code>i</code> pointing to a different element than it did before, or else it will invalidate <code>i</code> entirely. (A <code><a class="el" href="stldoc_Vector.html">Vector</a>&lt;T&gt;iterator</code> will be invalidated, for example, if an insertion requires a reallocation.) However, suppose that <code>i</code> and <code>j</code> are both iterators into a <a class="el" href="stldoc_Vector.html">Vector</a>, and there exists some integer <code>n</code> such that <code>i == j + n</code>. In that case, even if elements are inserted into the vector and <code>i</code> and <code>j</code> point to different elements, the relation between the two iterators will still hold. An <code>slist</code> is exactly the opposite: iterators will not be invalidated, and will not be made to point to different elements, but, for <code>slist</code> iterators, the predecessor/successor relationship is not invariant. </p>
<p><a class="anchor" id="3"></a>[3] This member function relies on <em>member template</em> functions, which at present (early 1998) are not supported by all compilers. If your compiler supports member templates, you can call this function with any type of <a class="el" href="stldoc_InputIterator.html">InputIterator</a>. If your compiler does not yet support member templates, though, then the arguments must either be of type <code>const value_type*</code> or of type <code>slist::const_iterator</code>. </p>
<p><a class="anchor" id="4"></a>[4] A similar property holds for all versions of <code><a class="el" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert()</a></code> and <code>erase()</code>. <code>Slist&lt;T, Alloc&gt;<a class="el" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert()</a></code> never invalidates any iterators, and <code>slist&lt;T, Alloc&gt;erase()</code> only invalidates iterators pointing to the elements that are actually being erased. </p>
<p><a class="anchor" id="5"></a>[5] This member function relies on <em>member template</em> functions, which at present (early 1998) are not supported by all compilers. You can only use this member function if your compiler supports member templates. </p>
<p><a class="anchor" id="6"></a>[6] The <code><a class="el" href="stldoc_reverse.html">reverse</a></code> algorithm works only for <a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a>. Even if <code><a class="el" href="stldoc_reverse.html">reverse</a></code> were extended to work with <a class="el" href="stldoc_ForwardIterator.html">ForwardIterator</a>, however, it would still be useful to have the <code>reverse</code> member function: it has different iterator invalidation semantics. That is, the <code>reverse</code> member function preserves the value that each iterator points to. Note also that the algorithm <code><a class="el" href="stldoc_reverse.html">reverse</a>(L.begin(), L.end())</code> uses <code>T</code>'s assignment operator, but the member function <code>L.reverse()</code> does not. </p>
<p><a class="anchor" id="7"></a>[7] The <code><a class="el" href="stldoc_sort.html">sort</a></code> algorithm works only for <a class="el" href="stldoc_RandomAccessIterator.html">RandomAccessIterator</a>. In principle, however, it would be possible to write a sort algorithm that also accepted <a class="el" href="stldoc_ForwardIterator.html">ForwardIterator</a>. Even if there were such a version of <code><a class="el" href="stldoc_sort.html">sort</a></code>, it would still be useful for <code>slist</code> to have a <code>sort</code> member function. That is, <code>sort</code> is provided as a member function not only for the sake of efficiency, but also because of the property that it preserves the values that list iterators point to. </p>
<h2><a class="anchor" id="See_also"></a>
See also</h2>
<p><a class="el" href="stldoc_BidirectionalIterator.html">BidirectionalIterator</a>, <a class="el" href="group__stldoc__ReversibleContainer.html">ReversibleContainer</a>, <a class="el" href="stldoc_Sequence.html">Sequence</a>, <code><a class="el" href="stldoc_List.html">List</a></code>, <code><a class="el" href="stldoc_Vector.html">Vector</a></code> </p>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
