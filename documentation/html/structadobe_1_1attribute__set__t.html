<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: attribute_set_t Class Reference</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="http://sourceforge.net/adobe/">Open @ Adobe</a><br/>
        <a href="http://opensource.adobe.com/">Adobe Open Source</a><br/>
        <a href="http://labs.adobe.com/">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.7.2 -->
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceadobe.html">adobe</a>      </li>
      <li><a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a>      </li>
    </ul>
  </div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>attribute_set_t Class Reference<br/>
<small>
[<a class="el" href="group__asl__xml__parser.html">XML Parser (and supporting constructs)</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="adobe::attribute_set_t" --><!-- doxytag: inherits="boost::equality_comparable" -->
<p>An associated array based on adobe::token_range_t. A utility class for the <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="xml__parser_8hpp_source.html">adobe/xml_parser.hpp</a>&gt;</code></p>

<p><a href="classadobe_1_1attribute__set__t-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t_1_1less__key__only__t.html">less_key_only_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t_1_1less__t.html">less_t</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef set_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#ad7a9b566b0a6a54b329c45d02595839b">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structadobe_1_1attribute__set__t.html#ad7a9b566b0a6a54b329c45d02595839b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#acaefede693fea7f92b26de5a6eba58de">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a460da6ff3481691aad1a7f466f58536b">mapped_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a98148112078dc998ef2c6f18e338952c">set_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef set_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a9f59f3144488c61d15f9c164e40556ae">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a>, <br class="typebreak"/>
<a class="el" href="structadobe_1_1attribute__set__t.html#a460da6ff3481691aad1a7f466f58536b">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structadobe_1_1attribute__set__t.html#ad7a9b566b0a6a54b329c45d02595839b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#aa4b02d4f1a8500fb07a551069060709f">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#ae44fab7321b7e5a88cad86d7b69190a1">count_collisions</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;other_set) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a9d73cc6e071323d35ec08735ca2e2245">count_same</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;other_set, bool mapped_matters=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#ac6e61de369e994009e36f344f99c15ad">empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structadobe_1_1attribute__set__t.html#ad7a9b566b0a6a54b329c45d02595839b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a350132543d80a1c1e5be844e6d2878ea">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a7bb27edf745ce1a354559c453e000c88">has_collisions</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;other_set) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#aef04f1899e941779d01d9d0c2e2825c0">insert</a> (I first, I last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#ad618e55c2abb017b025eeccfb41355c5">insert</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a> &amp;key, const <a class="el" href="structadobe_1_1attribute__set__t.html#a460da6ff3481691aad1a7f466f58536b">mapped_type</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#abfc579b7b8128f93ec1147f87c376518">insert</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a> &amp;attribute)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a247ef99a6cbe0a8af9dd0cf74619d354">lower_bound</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a> &amp;key, set_type::iterator &amp;result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#ab5f29133f7810c0aa001cbbe6e448d0b">lower_bound</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a> &amp;key, set_type::const_iterator &amp;result) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#afa054a440868165e4e83d5544dc66fdd">lower_bound</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a> &amp;attribute, set_type::iterator &amp;result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#ab4766dc61c5198642bdd80895ca9d7a4">lower_bound</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a> &amp;attribute, set_type::const_iterator &amp;result) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#afb905e199b5e878c2721778c41a729cd">merge</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;other_set) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structadobe_1_1attribute__set__t.html#a460da6ff3481691aad1a7f466f58536b">mapped_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a7848a70d8ade92f780bd8f2ce1c856ab">operator[]</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a> &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structadobe_1_1attribute__set__t.html#a9f59f3144488c61d15f9c164e40556ae">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a503ab01f6c0142145d3434f6924714e7">size</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#a8823f3424f3bba255592415eadcdb8d6">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;attribute_set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1attribute__set__t.html#aee2a6639aff6b1c3aaa66200b6d27c79">operator==</a> (const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;x, const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;y)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Model Of:</b></dt><dd><ul>
<li><a class="el" href="stldoc_EqualityComparable.html">EqualityComparable</a></li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Introduction</b></dt><dd>One of the key advantages to the <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">adobe::xml_parser_t</a> class is its performance in parsing documents. It is able to achieve fast parsing speeds by eliminating the copying of the original data during the parse, and only copying information to the output streams as the client of the parser sees fit. This mandates a host of accomodations given that the source data becomes deeply shared during a parse. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">adobe::attribute_set_t</a> class is a collection point for attributes that are found while parsing elements found within an xml-based document. These attributes are then handed back to the <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> client via the client callback mechanism. The <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a> storage implementation is copy-on-modify, so it is inexpensive to pass by value. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00049">49</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ad7a9b566b0a6a54b329c45d02595839b"></a><!-- doxytag: member="adobe::attribute_set_t::const_iterator" ref="ad7a9b566b0a6a54b329c45d02595839b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef set_type::const_iterator <a class="el" href="structadobe_1_1attribute__set__t.html#ad7a9b566b0a6a54b329c45d02595839b">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00056">56</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acaefede693fea7f92b26de5a6eba58de"></a><!-- doxytag: member="adobe::attribute_set_t::iterator" ref="acaefede693fea7f92b26de5a6eba58de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structadobe_1_1attribute__set__t.html#ad7a9b566b0a6a54b329c45d02595839b">const_iterator</a> <a class="el" href="structadobe_1_1attribute__set__t.html#acaefede693fea7f92b26de5a6eba58de">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00057">57</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b59669a9cdbd0d7a4654f9c739c3d40"></a><!-- doxytag: member="adobe::attribute_set_t::key_type" ref="a6b59669a9cdbd0d7a4654f9c739c3d40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00051">51</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a460da6ff3481691aad1a7f466f58536b"></a><!-- doxytag: member="adobe::attribute_set_t::mapped_type" ref="a460da6ff3481691aad1a7f466f58536b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> <a class="el" href="structadobe_1_1attribute__set__t.html#a460da6ff3481691aad1a7f466f58536b">mapped_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00052">52</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98148112078dc998ef2c6f18e338952c"></a><!-- doxytag: member="adobe::attribute_set_t::set_type" ref="a98148112078dc998ef2c6f18e338952c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a>&gt; <a class="el" href="structadobe_1_1attribute__set__t.html#a98148112078dc998ef2c6f18e338952c">set_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00054">54</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f59f3144488c61d15f9c164e40556ae"></a><!-- doxytag: member="adobe::attribute_set_t::size_type" ref="a9f59f3144488c61d15f9c164e40556ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef set_type::size_type <a class="el" href="structadobe_1_1attribute__set__t.html#a9f59f3144488c61d15f9c164e40556ae">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00055">55</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52cd4bf356a36ac22838445ebd799aa0"></a><!-- doxytag: member="adobe::attribute_set_t::value_type" ref="a52cd4bf356a36ac22838445ebd799aa0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a>, <a class="el" href="structadobe_1_1attribute__set__t.html#a460da6ff3481691aad1a7f466f58536b">mapped_type</a>&gt; <a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00053">53</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa4b02d4f1a8500fb07a551069060709f"></a><!-- doxytag: member="adobe::attribute_set_t::begin" ref="aa4b02d4f1a8500fb07a551069060709f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structadobe_1_1attribute__set__t.html#ad7a9b566b0a6a54b329c45d02595839b">const_iterator</a> begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>An unmodifiable (but dereferenceable) iterator to the first key-value pair in the attribute set </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00282">282</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a><!-- doxytag: member="adobe::attribute_set_t::clear" ref="ac8bb3912a3ce86b15842e79d0b421204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases the entire contents of the attribute set.</p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><code><a class="el" href="structadobe_1_1attribute__set__t.html#ac6e61de369e994009e36f344f99c15ad">empty()</a> == true</code> </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00296">296</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae44fab7321b7e5a88cad86d7b69190a1"></a><!-- doxytag: member="adobe::attribute_set_t::count_collisions" ref="ae44fab7321b7e5a88cad86d7b69190a1" args="(const attribute_set_t &amp;other_set) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t count_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>other_set</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A collision is defined as a key existing in both attribute sets but having different values. This routine searches two attribute sets and counts the number of collisions that exist between them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other_set</td><td>the other attribute set used for comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of collisions that exist between two sets. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00409">409</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d73cc6e071323d35ec08735ca2e2245"></a><!-- doxytag: member="adobe::attribute_set_t::count_same" ref="a9d73cc6e071323d35ec08735ca2e2245" args="(const attribute_set_t &amp;other_set, bool mapped_matters=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t count_same </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>other_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>mapped_matters</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Counts the number of attributes two attribute sets hold in similarity. When making the comparison the value of the attributes can be optionally omitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other_set</td><td>the other attribute set used for comparison </td></tr>
    <tr><td class="paramname">mapped_matters</td><td>toggles whether or not to consider the values found under the respective keys. If false, only the existence of the keys are required for the two sets to be considered 'sharing' that key. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00364">364</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6e61de369e994009e36f344f99c15ad"></a><!-- doxytag: member="adobe::attribute_set_t::empty" ref="ac6e61de369e994009e36f344f99c15ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Specifies whether or not this attribute set is empty </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00268">268</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a350132543d80a1c1e5be844e6d2878ea"></a><!-- doxytag: member="adobe::attribute_set_t::end" ref="a350132543d80a1c1e5be844e6d2878ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structadobe_1_1attribute__set__t.html#ad7a9b566b0a6a54b329c45d02595839b">const_iterator</a> end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to one-past-the last key-value pair in the attribute set </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00288">288</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bb27edf745ce1a354559c453e000c88"></a><!-- doxytag: member="adobe::attribute_set_t::has_collisions" ref="a7bb27edf745ce1a354559c453e000c88" args="(const attribute_set_t &amp;other_set) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool has_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>other_set</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A collision is defined as a key existing in both attribute sets but having different values. This routine searches two attribute sets looking to see if any collisions exist between them.</p>
<p>This routine is no slower (and is often faster than) the expression <code><a class="el" href="structadobe_1_1attribute__set__t.html#ae44fab7321b7e5a88cad86d7b69190a1">count_collisions()</a> != 0</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other_set</td><td>the other attribute set used for comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether or not there is at least one collision between the two attribute sets. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00391">391</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef04f1899e941779d01d9d0c2e2825c0"></a><!-- doxytag: member="adobe::attribute_set_t::insert" ref="aef04f1899e941779d01d9d0c2e2825c0" args="(I first, I last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"> <em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a range of key-value pairs into the current attribute set. Equivalent to invoking <a class="el" href="structadobe_1_1attribute__set__t.html#abfc579b7b8128f93ec1147f87c376518">insert()</a> over each element in the range.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code>last</code> must be reachable from <code>first</code>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A pointer to the first key-value pair in the range. </td></tr>
    <tr><td class="paramname">last</td><td>A pointer to one-past the last key-value pair in the range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00213">213</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad618e55c2abb017b025eeccfb41355c5"></a><!-- doxytag: member="adobe::attribute_set_t::insert" ref="ad618e55c2abb017b025eeccfb41355c5" args="(const key_type &amp;key, const mapped_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html#a460da6ff3481691aad1a7f466f58536b">mapped_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a key-value pair into the current attribute set. This is a helper implementation, allowing the client to specify the key and the value to be inserted as separate parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key under which the value is to be inserted </td></tr>
    <tr><td class="paramname">value</td><td>the value to be inserted into the attribute set </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00224">224</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abfc579b7b8128f93ec1147f87c376518"></a><!-- doxytag: member="adobe::attribute_set_t::insert" ref="abfc579b7b8128f93ec1147f87c376518" args="(const value_type &amp;attribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a key-value pair into the current attribute set. If there are more than one references to the internal instance of this attribute set, then a copy will be spun off before the insertion is made.</p>
<p>In the case when a value is already stored under the key specified in the attribute to be inserted, that value is replaced.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>the key-value pair to be inserted. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00192">192</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a247ef99a6cbe0a8af9dd0cf74619d354"></a><!-- doxytag: member="adobe::attribute_set_t::lower_bound" ref="a247ef99a6cbe0a8af9dd0cf74619d354" args="(const key_type &amp;key, set_type::iterator &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set_type::iterator &amp;&#160;</td>
          <td class="paramname"> <em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same logical result as std::lower_bound as it applies to <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a>. For this particular implementation only the attribute key is necessary as a parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key that is to be searched for in the <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a> </td></tr>
    <tr><td class="paramname">result</td><td>the resultant position to which the key fits</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if an attribute with this key exists within the <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a>. false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00118">118</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5f29133f7810c0aa001cbbe6e448d0b"></a><!-- doxytag: member="adobe::attribute_set_t::lower_bound" ref="ab5f29133f7810c0aa001cbbe6e448d0b" args="(const key_type &amp;key, set_type::const_iterator &amp;result) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set_type::const_iterator &amp;&#160;</td>
          <td class="paramname"> <em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>const-equivalent of lower_bound for <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a>. </p>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00135">135</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa054a440868165e4e83d5544dc66fdd"></a><!-- doxytag: member="adobe::attribute_set_t::lower_bound" ref="afa054a440868165e4e83d5544dc66fdd" args="(const value_type &amp;attribute, set_type::iterator &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set_type::iterator &amp;&#160;</td>
          <td class="paramname"> <em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same logical result as std::lower_bound as it applies to <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a>. Note that the value of the attribute is not used in the search; only the key is looked up.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>the attribute whose key is to be searched for in the <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a> </td></tr>
    <tr><td class="paramname">result</td><td>the resultant position to which the attribute key fits</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the attribute key exists within the <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a>. false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00099">99</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4766dc61c5198642bdd80895ca9d7a4"></a><!-- doxytag: member="adobe::attribute_set_t::lower_bound" ref="ab4766dc61c5198642bdd80895ca9d7a4" args="(const value_type &amp;attribute, set_type::const_iterator &amp;result) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html#a52cd4bf356a36ac22838445ebd799aa0">value_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set_type::const_iterator &amp;&#160;</td>
          <td class="paramname"> <em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>const-equivalent of lower_bound for <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a>. </p>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00124">124</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb905e199b5e878c2721778c41a729cd"></a><!-- doxytag: member="adobe::attribute_set_t::merge" ref="afb905e199b5e878c2721778c41a729cd" args="(const attribute_set_t &amp;other_set) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>other_set</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This merges two attribute sets together and places the union into dst. In the case where both attribute sets have an element with the same name, the value in the union will be from *this. The values are not compared when performing the union. This means the "override" attribute set should be the first source when you call this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other_set</td><td>the second <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a> with which this one will be merged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a> that is the result of merging this <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a> with the one passed in. This <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a> is left unchanged. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00171">171</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7848a70d8ade92f780bd8f2ce1c856ab"></a><!-- doxytag: member="adobe::attribute_set_t::operator[]" ref="a7848a70d8ade92f780bd8f2ce1c856ab" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structadobe_1_1attribute__set__t.html#a460da6ff3481691aad1a7f466f58536b">mapped_type</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html#a6b59669a9cdbd0d7a4654f9c739c3d40">key_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>key</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetches an unmodifiable value from an <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">attribute_set_t</a> stored under a given key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key under which the corresponding value should be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value if one exists; otherwise the NULL-token (See token_range_t). </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00147">147</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a503ab01f6c0142145d3434f6924714e7"></a><!-- doxytag: member="adobe::attribute_set_t::size" ref="a503ab01f6c0142145d3434f6924714e7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structadobe_1_1attribute__set__t.html#a9f59f3144488c61d15f9c164e40556ae">size_type</a> size </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Specifies the number of key-value pairs stored in this attribute set </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00275">275</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a8823f3424f3bba255592415eadcdb8d6"></a><!-- doxytag: member="adobe::attribute_set_t::operator&lt;&lt;" ref="a8823f3424f3bba255592415eadcdb8d6" args="(std::ostream &amp;s, const attribute_set_t &amp;attribute_set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines serialization functionality for an attribute set. Output format is similar to the format required for attribute sets in xml documents.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the stream to receive the output </td></tr>
    <tr><td class="paramname">attribute_set</td><td>the attribute set to be serialized to the stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00337">337</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee2a6639aff6b1c3aaa66200b6d27c79"></a><!-- doxytag: member="adobe::attribute_set_t::operator==" ref="aee2a6639aff6b1c3aaa66200b6d27c79" args="(const attribute_set_t &amp;x, const attribute_set_t &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines equality comparisons between two attribute sets. Equivalent to calling count_same over the attribute sets and arriving at the size of both sets (which, by implication, must be the same.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first attribute set </td></tr>
    <tr><td class="paramname">y</td><td>the second attribute set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the two attribute sets are equal. <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00319">319</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
