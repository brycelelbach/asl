<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: closed_hash.hpp Source File</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="http://sourceforge.net/adobe/">Open @ Adobe</a><br/>
        <a href="http://opensource.adobe.com/">Adobe Open Source</a><br/>
        <a href="http://labs.adobe.com/">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.7.2 -->
<div class="header">
  <div class="headertitle">
<h1>closed_hash.hpp</h1>  </div>
</div>
<div class="contents">
<a href="closed__hash_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">    Copyright 2005-2007 Adobe Systems Incorporated</span>
<a name="l00003"></a>00003 <span class="comment">    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt</span>
<a name="l00004"></a>00004 <span class="comment">    or a copy at http://stlab.adobe.com/licenses.html)</span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">/*************************************************************************************************/</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#ifndef ADOBE_CLOSED_HASH_HPP</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#define ADOBE_CLOSED_HASH_HPP</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span>
<a name="l00012"></a>00012 <span class="comment">/*************************************************************************************************/</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">adobe/config.hpp</a>&gt;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;<a class="code" href="closed__hash__fwd_8hpp.html">adobe/closed_hash_fwd.hpp</a>&gt;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;climits&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;boost/compressed_pair.hpp&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;boost/functional/hash.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;boost/iterator/iterator_adaptor.hpp&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/iterator/iterator_facade.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/type_traits/has_nothrow_constructor.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;boost/type_traits/remove_reference.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/operators.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/next_prior.hpp&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="lower__bound_8hpp.html">adobe/algorithm/lower_bound.hpp</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="conversion_8hpp.html">adobe/conversion.hpp</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="cstdint_8hpp.html">adobe/cstdint.hpp</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="empty_8hpp.html">adobe/empty.hpp</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="functional_8hpp.html">adobe/functional.hpp</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="set__next_8hpp.html">adobe/iterator/set_next.hpp</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="memory_8hpp.html">adobe/memory.hpp</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="move_8hpp.html">adobe/move.hpp</a>&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;<a class="code" href="utility_8hpp.html">adobe/utility.hpp</a>&gt;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;adobe/implementation/swap.hpp&gt;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">/*************************************************************************************************/</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">namespace </span>adobe {
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">/*************************************************************************************************/</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">namespace </span>implementation {
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/*************************************************************************************************/</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt; <span class="comment">// V is value_type(T) const qualified</span>
<a name="l00055"></a>00055 <span class="keyword">class </span>closed_hash_iterator : <span class="keyword">public</span> boost::iterator_facade&lt;closed_hash_iterator&lt;T, V&gt;, V,
<a name="l00056"></a>00056                                                            std::bidirectional_iterator_tag&gt;
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058     <span class="keyword">typedef</span> boost::iterator_facade&lt;closed_hash_iterator&lt;T, V&gt;, V,
<a name="l00059"></a>00059                                    std::bidirectional_iterator_tag&gt; inherited_t;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <span class="keyword">typedef</span> <span class="keyword">typename</span> T::node_t node_t;
<a name="l00062"></a>00062  <span class="keyword">public</span>:
<a name="l00063"></a>00063     <span class="keyword">typedef</span> <span class="keyword">typename</span> inherited_t::reference         reference;
<a name="l00064"></a>00064     <span class="keyword">typedef</span> <span class="keyword">typename</span> inherited_t::difference_type   difference_type;
<a name="l00065"></a>00065     <span class="keyword">typedef</span> <span class="keyword">typename</span> inherited_t::value_type        value_type;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067     closed_hash_iterator() : node_m(0) { }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> O&gt;
<a name="l00070"></a>00070     closed_hash_iterator(<span class="keyword">const</span> closed_hash_iterator&lt;T, O&gt;&amp; x) : node_m(x.node_m) { }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072  <span class="keyword">public</span>:
<a name="l00073"></a>00073     <span class="comment">/*</span>
<a name="l00074"></a>00074 <span class="comment">        REVISIT (sparent@adobe.com) : node_m should be private but</span>
<a name="l00075"></a>00075 <span class="comment">        &quot;gcc version 4.0.1 (Apple Inc. build 5465)&quot; doesn&#39;t like it.</span>
<a name="l00076"></a>00076 <span class="comment">    */</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     node_t* node_m;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080  <span class="keyword">private</span>:
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     reference dereference()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node_m-&gt;value_m; }
<a name="l00083"></a>00083     <span class="keywordtype">void</span> increment() { node_m = node_m-&gt;next(); }
<a name="l00084"></a>00084     <span class="keywordtype">void</span> decrement() { node_m = node_m-&gt;prior(); }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> O&gt;
<a name="l00087"></a>00087     <span class="keywordtype">bool</span> <a class="code" href="group__equal.html#gab42837481bc7251e15e3b67dd91f239c">equal</a>(<span class="keyword">const</span> closed_hash_iterator&lt;T, O&gt;&amp; y)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node_m == y.node_m; }
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     std::size_t state()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node_m-&gt;state(); }
<a name="l00090"></a>00090     <span class="keywordtype">void</span> set_state(std::size_t x) { <span class="keywordflow">return</span> node_m-&gt;set_state(x); }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="keyword">explicit</span> closed_hash_iterator(node_t* node) : node_m(node) { }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="group__abi__container.html#ga123a2e265d9c35109e121cb70b865f18">version_1::closed_hash_set</a>&lt;value_type, typename T::key_transform, typename T::hasher,
<a name="l00095"></a>00095             typename T::key_equal, typename T::allocator_type&gt;;
<a name="l00096"></a>00096     friend class boost::iterator_core_access;
<a name="l00097"></a>00097     friend struct unsafe::set_next_fn&lt;closed_hash_iterator&gt;;
<a name="l00098"></a>00098 };
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">/*************************************************************************************************/</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 } <span class="comment">// namespace implementation</span>
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment">/*************************************************************************************************/</span>
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="namespaceadobe_1_1unsafe.html">00106</a> namespace unsafe {
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt;
<a name="l00109"></a>00109 <span class="keyword">struct </span>set_next_fn&lt;implementation::closed_hash_iterator&lt;T, V&gt; &gt;
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111     <span class="keyword">typedef</span> <span class="keyword">typename</span> implementation::closed_hash_iterator&lt;T, V&gt; iterator;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="keywordtype">void</span> operator()(iterator x, iterator y)<span class="keyword"> const</span>
<a name="l00114"></a>00114 <span class="keyword">    </span>{ <a class="code" href="group__adobe__iterator.html#ga5f4d1f99bf3aae004dd736f8a3fdb999">set_next</a>(*x.node_m, *y.node_m); }
<a name="l00115"></a>00115 };
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 } <span class="comment">// namespace unsafe</span>
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">/*************************************************************************************************/</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="preprocessor">#ifndef ADOBE_NO_DOCUMENTATION</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>
<a name="l00123"></a>00123 <span class="keyword">namespace </span>version_1 {
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="preprocessor">#endif</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span>
<a name="l00127"></a>00127 <span class="comment">/*************************************************************************************************/</span>
<a name="l00128"></a>00128 
<a name="l00152"></a>00152 <span class="keyword">template</span>&lt;   <span class="keyword">typename</span> T,
<a name="l00153"></a>00153             <span class="keyword">typename</span> KeyTransform,
<a name="l00154"></a>00154             <span class="keyword">typename</span> Hash,
<a name="l00155"></a>00155             <span class="keyword">typename</span> Pred,
<a name="l00156"></a>00156             <span class="keyword">typename</span> A&gt;
<a name="l00157"></a><a class="code" href="classadobe_1_1closed__hash__set.html">00157</a> <span class="keyword">class </span><a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a> : boost::<a class="code" href="classboost_1_1equality__comparable.html">equality_comparable</a>&lt;closed_hash_set&lt;T, KeyTransform, Hash, Pred, A&gt;,
<a name="l00158"></a>00158                                         closed_hash_set&lt;T, KeyTransform, Hash, Pred, A&gt;,
<a name="l00159"></a>00159                                         empty_base&lt;closed_hash_set&lt;T, KeyTransform, Hash, Pred, A&gt; &gt; &gt;
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161  <span class="keyword">public</span>:
<a name="l00162"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a39dd655c38bd13b1b62a7b5254e91364">00162</a>     <span class="keyword">typedef</span> KeyTransform                        <a class="code" href="classadobe_1_1closed__hash__set.html#a39dd655c38bd13b1b62a7b5254e91364">key_transform</a>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_reference&lt;typename key_transform::result_type&gt;::type
<a name="l00165"></a><a class="code" href="classadobe_1_1closed__hash__set.html#aea62ca54d915711e5c594c11e8c65f11">00165</a>                                                 <a class="code" href="classadobe_1_1closed__hash__set.html#aea62ca54d915711e5c594c11e8c65f11">key_type</a>;
<a name="l00166"></a>00166 
<a name="l00167"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a265a253612b46abed17c61b0a5e5ce30">00167</a>     <span class="keyword">typedef</span> T                                   <a class="code" href="classadobe_1_1closed__hash__set.html#a265a253612b46abed17c61b0a5e5ce30">value_type</a>;
<a name="l00168"></a><a class="code" href="classadobe_1_1closed__hash__set.html#af7b8e1e82680d9ca2c069a5a7ee77f28">00168</a>     <span class="keyword">typedef</span> Hash                                <a class="code" href="classadobe_1_1closed__hash__set.html#af7b8e1e82680d9ca2c069a5a7ee77f28">hasher</a>;
<a name="l00169"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ac20c7adf363889ffc8c78183f3e9e942">00169</a>     <span class="keyword">typedef</span> Pred                                <a class="code" href="classadobe_1_1closed__hash__set.html#ac20c7adf363889ffc8c78183f3e9e942">key_equal</a>;
<a name="l00170"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">00170</a>     <span class="keyword">typedef</span> A                                   <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>;
<a name="l00171"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ad25b518036b886d8f35a3c059301d007">00171</a>     <span class="keyword">typedef</span> <a class="code" href="structadobe_1_1pair.html">value_type</a>*                         <a class="code" href="classadobe_1_1closed__hash__set.html#ad25b518036b886d8f35a3c059301d007">pointer</a>;
<a name="l00172"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a13c57dab17e2c903cadfa5e35ba84064">00172</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="structadobe_1_1pair.html">value_type</a>*                   <a class="code" href="classadobe_1_1closed__hash__set.html#a13c57dab17e2c903cadfa5e35ba84064">const_pointer</a>;
<a name="l00173"></a><a class="code" href="classadobe_1_1closed__hash__set.html#abe8933d436779a43cb5c1896ff5f2918">00173</a>     <span class="keyword">typedef</span> <a class="code" href="structadobe_1_1pair.html">value_type</a>&amp;                         <a class="code" href="classadobe_1_1closed__hash__set.html#abe8933d436779a43cb5c1896ff5f2918">reference</a>;
<a name="l00174"></a><a class="code" href="classadobe_1_1closed__hash__set.html#afdb67657e63a66ed3fae7b0c9fd81b48">00174</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="structadobe_1_1pair.html">value_type</a>&amp;                   <a class="code" href="classadobe_1_1closed__hash__set.html#afdb67657e63a66ed3fae7b0c9fd81b48">const_reference</a>;
<a name="l00175"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">00175</a>     <span class="keyword">typedef</span> std::size_t                         <a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a>;
<a name="l00176"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ad319fc54a93a2c7058c70e40428ed2e2">00176</a>     <span class="keyword">typedef</span> std::ptrdiff_t                      <a class="code" href="classadobe_1_1closed__hash__set.html#ad319fc54a93a2c7058c70e40428ed2e2">difference_type</a>;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="keyword">friend</span> <span class="keyword">class </span>implementation::closed_hash_iterator&lt;<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>, <a class="code" href="structadobe_1_1pair.html">value_type</a>&gt;;
<a name="l00179"></a>00179     <span class="keyword">friend</span> <span class="keyword">class </span>implementation::closed_hash_iterator&lt;<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>, const <a class="code" href="structadobe_1_1pair.html">value_type</a>&gt;;
<a name="l00180"></a>00180 
<a name="l00181"></a><a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">00181</a>     <span class="keyword">typedef</span> implementation::closed_hash_iterator&lt;closed_hash_set, value_type&gt;       <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>;
<a name="l00182"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a96af92cff83ecc57d226f5e3df7f173b">00182</a>     <span class="keyword">typedef</span> implementation::closed_hash_iterator&lt;closed_hash_set, const value_type&gt; <a class="code" href="classadobe_1_1closed__hash__set.html#a96af92cff83ecc57d226f5e3df7f173b">const_iterator</a>;
<a name="l00183"></a>00183 
<a name="l00184"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a92b881db836646f4039adcbb73c8595f">00184</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;         <a class="code" href="classadobe_1_1closed__hash__set.html#a92b881db836646f4039adcbb73c8595f">reverse_iterator</a>;
<a name="l00185"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a421ef78ccdc84f0f6b2b14e2732527ba">00185</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;   <a class="code" href="classadobe_1_1closed__hash__set.html#a421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a>;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187  <span class="keyword">private</span>:
<a name="l00188"></a>00188     <span class="keyword">enum</span>
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190         state_free          = 0,
<a name="l00191"></a>00191         state_home          = 1,
<a name="l00192"></a>00192         state_misplaced     = 2
<a name="l00193"></a>00193     };
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="comment">// U is derived node</span>
<a name="l00196"></a>00196     <span class="keyword">struct </span>list_node_base
<a name="l00197"></a>00197     {
<a name="l00198"></a>00198         list_node_base() { next_m = <span class="keyword">static_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); prior_m = <span class="keyword">static_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         U* address() { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00201"></a>00201         <span class="keyword">const</span> U* address()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         operator U&amp; () { <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00204"></a>00204         operator const U&amp; ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__adobe__iterator.html#ga5f4d1f99bf3aae004dd736f8a3fdb999">set_next</a>(U&amp; x, U&amp; y)
<a name="l00207"></a>00207         { x.next_m = <span class="keyword">reinterpret_cast&lt;</span>U*<span class="keyword">&gt;</span>(<a class="code" href="group__tr1.html#ga83242de74310b4aec3fc506bc3644211">uintptr_t</a>(&amp;y) | <a class="code" href="group__tr1.html#ga83242de74310b4aec3fc506bc3644211">uintptr_t</a>(x.state())); y.prior_m = &amp;x; }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> set_next_raw(U&amp; x, U&amp; y)
<a name="l00210"></a>00210         { x.next_m = &amp;y; y.prior_m = &amp;x; }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         std::size_t state()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::size_t(<a class="code" href="group__tr1.html#ga83242de74310b4aec3fc506bc3644211">uintptr_t</a>(next_m) &amp; <a class="code" href="group__tr1.html#ga83242de74310b4aec3fc506bc3644211">uintptr_t</a>(0x03UL)); }
<a name="l00213"></a>00213         <span class="keywordtype">void</span> set_state(std::size_t x)
<a name="l00214"></a>00214         {
<a name="l00215"></a>00215             assert(x &lt; 0x04UL);
<a name="l00216"></a>00216             next_m = <span class="keyword">reinterpret_cast&lt;</span>U*<span class="keyword">&gt;</span>(<a class="code" href="group__tr1.html#ga83242de74310b4aec3fc506bc3644211">uintptr_t</a>(next()) | <a class="code" href="group__tr1.html#ga83242de74310b4aec3fc506bc3644211">uintptr_t</a>(x));
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         U* next()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span><a class="code" href="group__tr1.html#ga83242de74310b4aec3fc506bc3644211">uintptr_t</a><span class="keyword">&gt;</span>(next_m) &amp; ~<a class="code" href="group__tr1.html#ga83242de74310b4aec3fc506bc3644211">uintptr_t</a>(0x03UL)); }
<a name="l00220"></a>00220         U* prior()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> prior_m; }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222      <span class="keyword">private</span>:
<a name="l00223"></a>00223         U* next_m;
<a name="l00224"></a>00224         U* prior_m;
<a name="l00225"></a>00225     };
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <span class="keyword">struct </span>node_t : list_node_base&lt;node_t&gt;
<a name="l00228"></a>00228     {
<a name="l00229"></a>00229         T           value_m;
<a name="l00230"></a>00230     };
<a name="l00231"></a>00231 
<a name="l00232"></a>00232     <span class="keyword">typedef</span> list_node_base&lt;node_t&gt; node_base_t;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234     <span class="keyword">struct </span>header_t
<a name="l00235"></a>00235     {
<a name="l00236"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html">00236</a>         <span class="keyword">struct </span><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html">compact_header_t</a>
<a name="l00237"></a>00237         {
<a name="l00238"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#a57a28b2c46effffc0c48045a43f0b6fc">00238</a>             boost::compressed_pair&lt;allocator_type, node_base_t&gt; <a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#a57a28b2c46effffc0c48045a43f0b6fc">alloc_free_tail_m</a>;
<a name="l00239"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#a837dc8a3af3eb4f51d20cbff7f03a168">00239</a>             node_base_t <a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#a837dc8a3af3eb4f51d20cbff7f03a168">used_tail_m</a>;
<a name="l00240"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#a72533e0491ebe6ad4e0439a0cd41d107">00240</a>             std::size_t <a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#a72533e0491ebe6ad4e0439a0cd41d107">capacity_m</a>;
<a name="l00241"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#abe627e64ae3a6c5a067a940605d559f9">00241</a>             std::size_t <a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#abe627e64ae3a6c5a067a940605d559f9">size_m</a>;
<a name="l00242"></a>00242         };
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         <span class="comment">/*</span>
<a name="l00245"></a>00245 <span class="comment">        NOTE (sparent) - the assumption is that the initial items are pointers and that size_t is</span>
<a name="l00246"></a>00246 <span class="comment">        either equal to the sizeof a pointer or a lower power of two so this packs tightly.</span>
<a name="l00247"></a>00247 <span class="comment">        */</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249         <a class="code" href="namespaceadobe.html#a0d19002ca08b6fc1baf4fad3522925c3">BOOST_STATIC_ASSERT</a>(!(<span class="keyword">sizeof</span>(A) == <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) || <span class="keyword">sizeof</span>(A) == 0)
<a name="l00250"></a>00250             || (<span class="keyword">sizeof</span>(<a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html">compact_header_t</a>) == (<span class="keyword">sizeof</span>(<a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>) + 2 * <span class="keyword">sizeof</span>(node_base_t) + 2 *
<a name="l00251"></a>00251                 <span class="keyword">sizeof</span>(std::size_t))));
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         <a class="code" href="structadobe_1_1aligned__storage.html">aligned_storage&lt;compact_header_t&gt;</a> header_m;
<a name="l00254"></a>00254         node_t      storage_m[1];
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>&amp;  allocator() { <span class="keywordflow">return</span> header_m.<a class="code" href="structadobe_1_1aligned__storage.html#a73f799e2233b063893121b058004f575">get</a>().<a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#a57a28b2c46effffc0c48045a43f0b6fc">alloc_free_tail_m</a>.first(); }
<a name="l00257"></a>00257         <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>&amp; allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().alloc_free_tail_m.first(); }
<a name="l00258"></a>00258         node_base_t&amp;  free_tail() { <span class="keywordflow">return</span> header_m.get().alloc_free_tail_m.second(); }
<a name="l00259"></a>00259         <span class="keyword">const</span> node_base_t&amp; free_tail()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().alloc_free_tail_m.second(); }
<a name="l00260"></a>00260         node_base_t&amp;  used_tail() { <span class="keywordflow">return</span> header_m.get().used_tail_m; }
<a name="l00261"></a>00261         <span class="keyword">const</span> node_base_t&amp; used_tail()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().used_tail_m; }
<a name="l00262"></a>00262         std::size_t&amp;  capacity() { <span class="keywordflow">return</span> header_m.get().capacity_m; }
<a name="l00263"></a>00263         <span class="keyword">const</span> std::size_t&amp; capacity()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().capacity_m; }
<a name="l00264"></a>00264         std::size_t&amp;  <a class="code" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() { <span class="keywordflow">return</span> header_m.get().size_m; }
<a name="l00265"></a>00265         <span class="keyword">const</span> std::size_t&amp; <a class="code" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().size_m; }
<a name="l00266"></a>00266     };
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <span class="keyword">typedef</span> node_t* node_ptr;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     <span class="keyword">typedef</span> boost::compressed_pair&lt; hasher,
<a name="l00271"></a>00271                                     boost::compressed_pair&lt; key_equal,
<a name="l00272"></a>00272                                                             boost::compressed_pair&lt; key_transform,
<a name="l00273"></a>00273                                                                                     header_t*
<a name="l00274"></a>00274                                                                                   &gt;
<a name="l00275"></a>00275                                                           &gt;
<a name="l00276"></a>00276                                   &gt; data_t;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     data_t  data_m;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     <span class="keyword">typedef</span> header_t* header_pointer;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282     <span class="keyword">const</span> header_pointer&amp; header()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_m.second().second().second(); }
<a name="l00283"></a>00283     header_pointer&amp; header() { <span class="keywordflow">return</span> data_m.second().second().second(); }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285  <span class="keyword">public</span>:
<a name="l00286"></a>00286     <span class="comment">// construct/destroy/copy</span>
<a name="l00287"></a>00287 
<a name="l00288"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a3d568316e3b40becf25203ae2bac5643">00288</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a3d568316e3b40becf25203ae2bac5643">closed_hash_set</a>() { header() = 0; }
<a name="l00289"></a>00289 
<a name="l00290"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ae9ab2c4ac6b91555f1b6a32c76b079a3">00290</a>     <span class="keyword">explicit</span> <a class="code" href="group__abi__container.html#ga123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(<a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a> n)
<a name="l00291"></a>00291     {
<a name="l00292"></a>00292         header() = 0;
<a name="l00293"></a>00293         allocate(<a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>(), n);
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295 
<a name="l00296"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a34f0a7991a6b5c4e7111bd13b7be2fa5">00296</a>     <a class="code" href="group__abi__container.html#ga123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(<a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a> n, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#af7b8e1e82680d9ca2c069a5a7ee77f28">hasher</a>&amp; hf, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#ac20c7adf363889ffc8c78183f3e9e942">key_equal</a>&amp; eq = <a class="code" href="classadobe_1_1closed__hash__set.html#ac20c7adf363889ffc8c78183f3e9e942">key_equal</a>(),
<a name="l00297"></a>00297                                                    <span class="keyword">const</span> <a class="code" href="structadobe_1_1get__element.html">key_transform</a>&amp; kf = <a class="code" href="structadobe_1_1get__element.html">key_transform</a>(),
<a name="l00298"></a>00298                                                    <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>&amp; a = <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>())
<a name="l00299"></a>00299     {
<a name="l00300"></a>00300         header() = 0;
<a name="l00301"></a>00301         data_m.first() = hf;
<a name="l00302"></a>00302         data_m.second().first() = eq;
<a name="l00303"></a>00303         data_m.second().second().first() = kf;
<a name="l00304"></a>00304         allocate(a, n);
<a name="l00305"></a>00305     }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models InputIterator</span>
<a name="l00308"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a0d1010cb73d6e1e023d2f7a4777656c0">00308</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a0d1010cb73d6e1e023d2f7a4777656c0">closed_hash_set</a>(I f, I l) { header() = 0; <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(f, l); }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models InputIterator</span>
<a name="l00311"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a16ddcde29b395ae25385311120330487">00311</a>     <a class="code" href="group__abi__container.html#ga123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(I f, I l, <a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a> n, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#af7b8e1e82680d9ca2c069a5a7ee77f28">hasher</a>&amp; hf = <a class="code" href="classadobe_1_1closed__hash__set.html#af7b8e1e82680d9ca2c069a5a7ee77f28">hasher</a>(),
<a name="l00312"></a>00312                                            <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#ac20c7adf363889ffc8c78183f3e9e942">key_equal</a>&amp; eq = <a class="code" href="classadobe_1_1closed__hash__set.html#ac20c7adf363889ffc8c78183f3e9e942">key_equal</a>(),
<a name="l00313"></a>00313                                            <span class="keyword">const</span> <a class="code" href="structadobe_1_1get__element.html">key_transform</a>&amp; kf = <a class="code" href="structadobe_1_1get__element.html">key_transform</a>(),
<a name="l00314"></a>00314                                            <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>&amp; a = <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>())
<a name="l00315"></a>00315     {
<a name="l00316"></a>00316         header() = 0;
<a name="l00317"></a>00317         data_m.first() = hf;
<a name="l00318"></a>00318         data_m.second().first() = eq;
<a name="l00319"></a>00319         data_m.second().second().first() = kf;
<a name="l00320"></a>00320         allocate(a, n);
<a name="l00321"></a>00321         <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(f, l);
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323 
<a name="l00324"></a><a class="code" href="classadobe_1_1closed__hash__set.html#acc9d1faa43faf0a10893e030f18e60fb">00324</a>     <a class="code" href="group__abi__container.html#ga123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; x) : data_m(x.data_m)
<a name="l00325"></a>00325     {
<a name="l00326"></a>00326         header() = 0;
<a name="l00327"></a>00327         allocate(x.<a class="code" href="classadobe_1_1closed__hash__set.html#acfbc5374e81f060b1cdffeb9c494ae86">get_allocator</a>(), x.<a class="code" href="classadobe_1_1closed__hash__set.html#a503ab01f6c0142145d3434f6924714e7">size</a>());
<a name="l00328"></a>00328         <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(x.<a class="code" href="classadobe_1_1closed__hash__set.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(), x.<a class="code" href="classadobe_1_1closed__hash__set.html#acad38d52497a975bfb6f2f6acd76631f">end</a>());
<a name="l00329"></a>00329     }
<a name="l00330"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a92d00a7bf493893de05a2ee93853a3e6">00330</a>     <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; <a class="code" href="classadobe_1_1closed__hash__set.html#a92d00a7bf493893de05a2ee93853a3e6">operator=</a>(<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a> x) { <a class="code" href="namespaceadobe.html#a5c6656b2ba51d81c71a97670f3b15a83">swap</a>(x, *<span class="keyword">this</span>); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00331"></a>00331 
<a name="l00332"></a><a class="code" href="classadobe_1_1closed__hash__set.html#acfbc5374e81f060b1cdffeb9c494ae86">00332</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a> get_allocator()<span class="keyword"> const</span>
<a name="l00333"></a>00333 <span class="keyword">    </span>{ <span class="keywordflow">return</span> header() ? header()-&gt;allocator() : <a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>(); }
<a name="l00334"></a>00334 
<a name="l00335"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a5ee6296d5a13e4837d677d74caad38c1">00335</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a5ee6296d5a13e4837d677d74caad38c1">closed_hash_set</a>(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from&lt;closed_hash_set&gt;</a> x) : data_m(x.source.data_m) { x.<a class="code" href="structadobe_1_1move__from.html#a3fc86dd652c668de2fecaa29375d0d2b">source</a>.header() = 0; }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="preprocessor">#if 0</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models ForwardIterator</span>
<a name="l00339"></a>00339     <a class="code" href="group__abi__container.html#ga123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(I f, I l, move_ctor) { header() = 0; move_insert(f, l); }
<a name="l00340"></a>00340 <span class="preprocessor">#endif</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span>
<a name="l00342"></a>00342     <span class="comment">// size and capacity</span>
<a name="l00343"></a>00343 
<a name="l00344"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a503ab01f6c0142145d3434f6924714e7">00344</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a503ab01f6c0142145d3434f6924714e7">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header() ? header()-&gt;size() : 0; }
<a name="l00345"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a0ab5ce862c0331d9e45a6e1774fca131">00345</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a0ab5ce862c0331d9e45a6e1774fca131">max_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a>(-1) / <span class="keyword">sizeof</span>(node_t); }
<a name="l00346"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ac6e61de369e994009e36f344f99c15ad">00346</a>     <span class="keywordtype">bool</span> <a class="code" href="classadobe_1_1closed__hash__set.html#ac6e61de369e994009e36f344f99c15ad">empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() == 0; }
<a name="l00347"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ab009512ed674371bda87b4a4a3fc7305">00347</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a> <a class="code" href="classadobe_1_1closed__hash__set.html#ab009512ed674371bda87b4a4a3fc7305">capacity</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header() ? header()-&gt;capacity() : 0; }
<a name="l00348"></a>00348 
<a name="l00349"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a562f7b24b47d3e7632a9896935c14d8b">00349</a>     <span class="keywordtype">void</span> reserve(<a class="code" href="classadobe_1_1closed__hash__set.html#a89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a> n)
<a name="l00350"></a>00350     {
<a name="l00351"></a>00351         <span class="keywordflow">if</span> (n &lt;= capacity()) <span class="keywordflow">return</span>;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353         <span class="keywordflow">if</span> (!header()) allocate(<a class="code" href="classadobe_1_1closed__hash__set.html#a8876e3aa4a94471d5f91b914f0d37759">allocator_type</a>(), n);
<a name="l00354"></a>00354         <span class="keywordflow">else</span>
<a name="l00355"></a>00355         {
<a name="l00356"></a>00356             <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a> tmp(n, hash_function(), key_eq(), key_function(), get_allocator());
<a name="l00357"></a>00357             tmp.<a class="code" href="classadobe_1_1closed__hash__set.html#a3ca9357c49ea5883e29501dee02ea5d7">move_insert</a>(begin(), end());
<a name="l00358"></a>00358             <a class="code" href="namespaceadobe.html#a5c6656b2ba51d81c71a97670f3b15a83">swap</a>(*<span class="keyword">this</span>, tmp);
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360     }
<a name="l00361"></a>00361 
<a name="l00362"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a67dbb7e2ef73eef7948ffcea921d6d56">00362</a>     <a class="code" href="structadobe_1_1get__element.html">key_transform</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a67dbb7e2ef73eef7948ffcea921d6d56">key_function</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_m.second().second().first(); }
<a name="l00363"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a1bfb95fcf670a1793ee7ecb7475493a3">00363</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#af7b8e1e82680d9ca2c069a5a7ee77f28">hasher</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a1bfb95fcf670a1793ee7ecb7475493a3">hash_function</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_m.first(); }
<a name="l00364"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a082eb35d8ade72f084455c3decee613f">00364</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#ac20c7adf363889ffc8c78183f3e9e942">key_equal</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a082eb35d8ade72f084455c3decee613f">key_eq</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_m.second().first(); }
<a name="l00365"></a>00365 
<a name="l00366"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ad69bd11391be1a1dba5c8202259664f8">00366</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>() { <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>(header() ? header()-&gt;used_tail().next() : 0); }
<a name="l00367"></a><a class="code" href="classadobe_1_1closed__hash__set.html#acad38d52497a975bfb6f2f6acd76631f">00367</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#acad38d52497a975bfb6f2f6acd76631f">end</a>() { <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>(header() ? header()-&gt;used_tail().address() : 0); }
<a name="l00368"></a>00368 
<a name="l00369"></a><a class="code" href="classadobe_1_1closed__hash__set.html#aa4b02d4f1a8500fb07a551069060709f">00369</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#aa4b02d4f1a8500fb07a551069060709f">begin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>(header() ? header()-&gt;used_tail().next() : 0); }
<a name="l00370"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a350132543d80a1c1e5be844e6d2878ea">00370</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a350132543d80a1c1e5be844e6d2878ea">end</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>(header() ? const_cast&lt;node_t*&gt;(header()-&gt;used_tail().address()) : 0); }
<a name="l00371"></a>00371 
<a name="l00372"></a><a class="code" href="classadobe_1_1closed__hash__set.html#acea44ed500a54b2bb93e16b86e81afa8">00372</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a92b881db836646f4039adcbb73c8595f">reverse_iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#acea44ed500a54b2bb93e16b86e81afa8">rbegin</a>() { <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a92b881db836646f4039adcbb73c8595f">reverse_iterator</a>(end()); }
<a name="l00373"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a68c599ddcbfddc65170de524ac165e44">00373</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a92b881db836646f4039adcbb73c8595f">reverse_iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a68c599ddcbfddc65170de524ac165e44">rend</a>() { <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a92b881db836646f4039adcbb73c8595f">reverse_iterator</a>(begin()); }
<a name="l00374"></a>00374 
<a name="l00375"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a04886aa70c34d66738e78bf70c675e66">00375</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a04886aa70c34d66738e78bf70c675e66">rbegin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a>(end()); }
<a name="l00376"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ab3c414470d5cea2986cfab7a90146cb6">00376</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#ab3c414470d5cea2986cfab7a90146cb6">rend</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a>(begin()); }
<a name="l00377"></a>00377 
<a name="l00378"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a09ec269da9e5936d292aaf134477eceb">00378</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="group__erase.html#gaea27cdb7a5b7013f3ca4e2102b28a096">erase</a>(<a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> location)
<a name="l00379"></a>00379     {
<a name="l00380"></a>00380         <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> next(boost::next(location));
<a name="l00381"></a>00381         <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> result = next;
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         <span class="keywordflow">if</span> ((location.state() == std::size_t(state_home)) &amp;&amp; (next != end())
<a name="l00384"></a>00384                 &amp;&amp; (next.state() == std::size_t(state_misplaced)))
<a name="l00385"></a>00385         {
<a name="l00386"></a>00386             <a class="code" href="namespaceadobe.html#a5c6656b2ba51d81c71a97670f3b15a83">swap</a>(*next, *location);
<a name="l00387"></a>00387             result = location;
<a name="l00388"></a>00388             location = next;
<a name="l00389"></a>00389         }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391         <a class="code" href="group__adobe__iterator.html#ga3adeba343a28c39563dc4aae37f22421">unsafe::skip_node</a>(location);
<a name="l00392"></a>00392         erase_raw(location);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394         --header()-&gt;size();
<a name="l00395"></a>00395 
<a name="l00396"></a>00396         <span class="keywordflow">return</span> result;
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398 
<a name="l00399"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a54aa36e2195f7b699df332329c7c0e66">00399</a>     std::size_t <a class="code" href="group__erase.html#gaea27cdb7a5b7013f3ca4e2102b28a096">erase</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aea62ca54d915711e5c594c11e8c65f11">key_type</a>&amp; key)
<a name="l00400"></a>00400     {
<a name="l00401"></a>00401         <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> node(<a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(key));
<a name="l00402"></a>00402         <span class="keywordflow">if</span> (node == end()) <span class="keywordflow">return</span> 0;
<a name="l00403"></a>00403         <a class="code" href="group__erase.html#gaea27cdb7a5b7013f3ca4e2102b28a096">erase</a>(node);
<a name="l00404"></a>00404         <span class="keywordflow">return</span> 1;
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406 
<a name="l00407"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ac8bb3912a3ce86b15842e79d0b421204">00407</a>     <span class="keywordtype">void</span> <a class="code" href="group__sequence__view.html#gae86d3d95373ce0d9f1d92c9f62b58d14" title="SequenceView concept requirement.">clear</a>()
<a name="l00408"></a>00408     {
<a name="l00409"></a>00409         <span class="keywordflow">for</span>(<a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> first(begin()), last(end()); first != last; first = <a class="code" href="group__erase.html#gaea27cdb7a5b7013f3ca4e2102b28a096">erase</a>(first)) ;
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411 
<a name="l00412"></a><a class="code" href="classadobe_1_1closed__hash__set.html#adc204502ef1606c9daa4a613da6aacfb">00412</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> <a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aea62ca54d915711e5c594c11e8c65f11">key_type</a>&amp; key)<span class="keyword"> const</span>
<a name="l00413"></a>00413 <span class="keyword">    </span>{
<a name="l00414"></a>00414         <span class="keywordflow">return</span> <a class="code" href="group__conversion.html#ga491e23f2732f7ee1f63acd34a515cba3">adobe::remove_const</a>(*this).find(key);
<a name="l00415"></a>00415     }
<a name="l00416"></a>00416 
<a name="l00417"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a9c9766a96c492f3e9e5861d6b4f87387">00417</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aea62ca54d915711e5c594c11e8c65f11">key_type</a>&amp; key)
<a name="l00418"></a>00418     {
<a name="l00419"></a>00419         <span class="keywordflow">if</span> (empty()) <span class="keywordflow">return</span> end();
<a name="l00420"></a>00420 
<a name="l00421"></a>00421         <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> node(bucket(key));
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         <span class="keywordflow">if</span> (node.state() != std::size_t(state_home)) <span class="keywordflow">return</span> end();
<a name="l00424"></a>00424 
<a name="l00425"></a>00425         <span class="keywordflow">return</span> <a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(node, key);
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427 
<a name="l00428"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a33c1ee0eb39360edec2a985301b9d631">00428</a>     std::pair&lt;const_iterator, const_iterator&gt; <a class="code" href="group__equal__range.html#ga2f886d190fe33fac6a38f6d79500f887">equal_range</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aea62ca54d915711e5c594c11e8c65f11">key_type</a>&amp; key)<span class="keyword"> const</span>
<a name="l00429"></a>00429 <span class="keyword">    </span>{
<a name="l00430"></a>00430         <a class="code" href="classadobe_1_1closed__hash__set.html#a96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> result = <a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(key);
<a name="l00431"></a>00431         <span class="keywordflow">if</span> (result == end()) <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#ga86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(result, result);
<a name="l00432"></a>00432         <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#ga86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(result, boost::next(result));
<a name="l00433"></a>00433     }
<a name="l00434"></a>00434 
<a name="l00435"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a97bb054bc81e97ec55f0b539cdcbfcde">00435</a>     std::pair&lt;iterator, iterator&gt; <a class="code" href="group__equal__range.html#ga2f886d190fe33fac6a38f6d79500f887">equal_range</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aea62ca54d915711e5c594c11e8c65f11">key_type</a>&amp; key)
<a name="l00436"></a>00436     {
<a name="l00437"></a>00437         <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> result = <a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(key);
<a name="l00438"></a>00438         <span class="keywordflow">if</span> (result == end()) <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#ga86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(result, result);
<a name="l00439"></a>00439         <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#ga86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(result, boost::next(result));
<a name="l00440"></a>00440     }
<a name="l00441"></a>00441 
<a name="l00442"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a1f51634779163f098196e3ac00d1489b">00442</a>     std::size_t <a class="code" href="group__count.html#ga0a7c479c6dffa60d3aae2abdcce31a5e" title="count implementation">count</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aea62ca54d915711e5c594c11e8c65f11">key_type</a>&amp; key)<span class="keyword"> const</span>
<a name="l00443"></a>00443 <span class="keyword">    </span>{ <span class="keywordflow">return</span> std::size_t(<a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(key) != end()); }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models InputIterator</span>
<a name="l00446"></a><a class="code" href="classadobe_1_1closed__hash__set.html#aef04f1899e941779d01d9d0c2e2825c0">00446</a>     <span class="keywordtype">void</span> <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(I first, I last)
<a name="l00447"></a>00447     { <span class="keywordflow">while</span> (first != last) { <a class="code" href="classadobe_1_1closed__hash__set.html#aef04f1899e941779d01d9d0c2e2825c0">insert</a>(*first); ++first; } }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models ForwardIterator</span>
<a name="l00450"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a3ca9357c49ea5883e29501dee02ea5d7">00450</a>     <span class="keywordtype">void</span> move_insert(I first, I last)
<a name="l00451"></a>00451     { <span class="keywordflow">while</span> (first != last) { <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="group__move__related.html#ga19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor. This call, with the help of the return value optimization, will cause x to be moved instead of copied to its destination. See adobe/test/move/main.cpp for examples.">adobe::move</a>(*first)); ++first; } }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <span class="comment">/*</span>
<a name="l00454"></a>00454 <span class="comment">        NOTE (sparent): If there is not enough space for one element we will reserve the space</span>
<a name="l00455"></a>00455 <span class="comment">        prior to attempting the insert even if the item is already in the hash table. Without</span>
<a name="l00456"></a>00456 <span class="comment">        recalculating the bucket (a potentially expensive operation) there is no other solution.</span>
<a name="l00457"></a>00457 <span class="comment">    */</span>
<a name="l00458"></a>00458 
<a name="l00459"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ad4d9d7f0fbdb1d46c4d5bea71ba0648a">00459</a>     std::pair&lt;iterator, bool&gt; <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="structadobe_1_1pair.html">value_type</a> x)
<a name="l00460"></a>00460     {
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (capacity() == <a class="code" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>()) reserve(<a class="code" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() ? 2 * <a class="code" href="group__selection__algorithms.html#ga7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() : 3);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463         <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> node = bucket(key_function()(x));
<a name="l00464"></a>00464 
<a name="l00465"></a>00465         <span class="keywordflow">switch</span> (node.state())
<a name="l00466"></a>00466         {
<a name="l00467"></a>00467         <span class="keywordflow">case</span> state_home:
<a name="l00468"></a>00468             {
<a name="l00469"></a>00469             <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> found = <a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(node, key_function()(x));
<a name="l00470"></a>00470             <span class="keywordflow">if</span> (found != end()) {
<a name="l00471"></a>00471                 *found = <a class="code" href="group__move__related.html#ga19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor. This call, with the help of the return value optimization, will cause x to be moved instead of copied to its destination. See adobe/test/move/main.cpp for examples.">adobe::move</a>(x);
<a name="l00472"></a>00472                 <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#ga86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(found, <span class="keyword">false</span>);
<a name="l00473"></a>00473             }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475             <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> free(begin_free());
<a name="l00476"></a>00476             insert_raw(free, <a class="code" href="group__move__related.html#ga19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor. This call, with the help of the return value optimization, will cause x to be moved instead of copied to its destination. See adobe/test/move/main.cpp for examples.">adobe::move</a>(x), state_misplaced);
<a name="l00477"></a>00477             <a class="code" href="group__adobe__iterator.html#ga38d33c4c128cae32602cefd55503a6d2">unsafe::splice_node_range</a>(node, free, free);
<a name="l00478"></a>00478             node = free;
<a name="l00479"></a>00479             }
<a name="l00480"></a>00480             <span class="keywordflow">break</span>;
<a name="l00481"></a>00481         <span class="keywordflow">case</span> state_misplaced:
<a name="l00482"></a>00482             {
<a name="l00483"></a>00483             <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> free(begin_free());
<a name="l00484"></a>00484             insert_raw(free, <a class="code" href="group__move__related.html#ga19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor. This call, with the help of the return value optimization, will cause x to be moved instead of copied to its destination. See adobe/test/move/main.cpp for examples.">adobe::move</a>(*node), state_misplaced);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486             <a class="code" href="group__adobe__iterator.html#ga5f4d1f99bf3aae004dd736f8a3fdb999">unsafe::set_next</a>(boost::prior(node), free);
<a name="l00487"></a>00487             <a class="code" href="group__adobe__iterator.html#ga5f4d1f99bf3aae004dd736f8a3fdb999">unsafe::set_next</a>(free, boost::next(node));
<a name="l00488"></a>00488 
<a name="l00489"></a>00489             erase_raw(node);
<a name="l00490"></a>00490             }
<a name="l00491"></a>00491             <span class="comment">// fall through</span>
<a name="l00492"></a>00492         <span class="keywordflow">default</span>: <span class="comment">// state_free</span>
<a name="l00493"></a>00493             {
<a name="l00494"></a>00494             insert_raw(node, <a class="code" href="group__move__related.html#ga19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor. This call, with the help of the return value optimization, will cause x to be moved instead of copied to its destination. See adobe/test/move/main.cpp for examples.">adobe::move</a>(x), state_home);
<a name="l00495"></a>00495             <a class="code" href="group__adobe__iterator.html#ga38d33c4c128cae32602cefd55503a6d2">unsafe::splice_node_range</a>(end(), node, node);
<a name="l00496"></a>00496             }
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498         header()-&gt;size() += 1;
<a name="l00499"></a>00499         <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#ga86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(node, <span class="keyword">true</span>);
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501 
<a name="l00502"></a><a class="code" href="classadobe_1_1closed__hash__set.html#aa02a2d407c9368eaae3d79ea4cc2e1a2">00502</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>, <a class="code" href="structadobe_1_1pair.html">value_type</a> x)
<a name="l00503"></a>00503     {
<a name="l00504"></a>00504         <span class="keywordflow">return</span> <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="group__move__related.html#ga19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor. This call, with the help of the return value optimization, will cause x to be moved instead of copied to its destination. See adobe/test/move/main.cpp for examples.">adobe::move</a>(x)).first;
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506 
<a name="l00507"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a4cea53c913040da9b4d84e77eb7844cd">00507</a>     ~<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>()
<a name="l00508"></a>00508     {
<a name="l00509"></a>00509         <span class="keywordflow">if</span> (header())
<a name="l00510"></a>00510         {
<a name="l00511"></a>00511             <span class="keywordflow">for</span>(<a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> first(begin()), last(end()); first != last; ++first) <a class="code" href="namespaceadobe.html#a5552b0f660612c91fd30793df8d06091">destroy</a>(&amp;*first);
<a name="l00512"></a>00512             raw_allocator alloc(get_allocator());
<a name="l00513"></a>00513             alloc.deallocate(reinterpret_cast&lt;char*&gt;(header()), 0);
<a name="l00514"></a>00514         }
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516 
<a name="l00517"></a><a class="code" href="classadobe_1_1closed__hash__set.html#abc575ac3431045320d145610382a3011">00517</a>     <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="namespaceadobe.html#a5c6656b2ba51d81c71a97670f3b15a83">swap</a>(<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; x, <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; y)
<a name="l00518"></a>00518     {
<a name="l00519"></a>00519         <a class="code" href="namespaceadobe.html#a5c6656b2ba51d81c71a97670f3b15a83">std::swap</a>(x.data_m, y.data_m);
<a name="l00520"></a>00520     }
<a name="l00521"></a>00521 
<a name="l00522"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a9266b5954937bd5257be1f6484b3f16c">00522</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceadobe.html#aa70510cd533bc8e226d58fc472ca1f6b">operator==</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; y)
<a name="l00523"></a>00523     {
<a name="l00524"></a>00524         <span class="keywordflow">if</span> (x.<a class="code" href="classadobe_1_1closed__hash__set.html#a503ab01f6c0142145d3434f6924714e7">size</a>() != y.<a class="code" href="classadobe_1_1closed__hash__set.html#a503ab01f6c0142145d3434f6924714e7">size</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00525"></a>00525         <span class="keywordflow">for</span> (<a class="code" href="classadobe_1_1closed__hash__set.html#a96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> first(x.<a class="code" href="classadobe_1_1closed__hash__set.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>()), last(x.<a class="code" href="classadobe_1_1closed__hash__set.html#acad38d52497a975bfb6f2f6acd76631f">end</a>()); first != last; ++first)
<a name="l00526"></a>00526         {
<a name="l00527"></a>00527             <a class="code" href="classadobe_1_1closed__hash__set.html#a96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> <a class="code" href="structadobe_1_1iter.html">iter</a>(y.<a class="code" href="classadobe_1_1closed__hash__set.html#adc204502ef1606c9daa4a613da6aacfb">find</a>(y.<a class="code" href="classadobe_1_1closed__hash__set.html#a67dbb7e2ef73eef7948ffcea921d6d56">key_function</a>()(*first)));
<a name="l00528"></a>00528             <span class="keywordflow">if</span> (iter == y.<a class="code" href="classadobe_1_1closed__hash__set.html#acad38d52497a975bfb6f2f6acd76631f">end</a>() || !(*first == *iter)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00531"></a>00531     }
<a name="l00532"></a>00532  <span class="keyword">private</span>:
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::template rebind&lt;char&gt;::other raw_allocator;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536 
<a name="l00537"></a>00537     <span class="keywordtype">void</span> allocate(<span class="keyword">const</span> allocator_type&amp; a, size_type n)
<a name="l00538"></a>00538     {
<a name="l00539"></a>00539         <span class="comment">// table of primes such that p[n + 1] = next_prime(2 * p[n])</span>
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         <span class="keyword">static</span> <span class="keyword">const</span> std::size_t prime_table[] = { 3UL, 7UL, 17UL, 37UL, 79UL, 163UL, 331UL, 673UL,
<a name="l00542"></a>00542             1361UL, 2729UL, 5471UL, 10949UL, 21911UL, 43853UL, 87719UL, 175447UL, 350899UL,
<a name="l00543"></a>00543             701819UL, 1403641UL, 2807303UL, 5614657UL, 11229331UL, 22458671UL, 44917381UL,
<a name="l00544"></a>00544             89834777UL, 179669557UL, 359339171UL, 718678369UL, 1437356741UL, 2874713497UL,
<a name="l00545"></a>00545             ULONG_MAX
<a name="l00546"></a>00546         };
<a name="l00547"></a>00547 
<a name="l00548"></a>00548         assert(!header() &amp;&amp; <span class="stringliteral">&quot;WARNING (sparent@adobe.com) : About to write over allocated header.&quot;</span>);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (n == 0 &amp;&amp; a == allocator_type()) <span class="keywordflow">return</span>;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         n = *<a class="code" href="namespaceadobe_1_1fn.html#a59e44aef9c93131146606040c0b15e38">adobe::lower_bound</a>(prime_table, n);
<a name="l00553"></a>00553 
<a name="l00554"></a>00554         raw_allocator alloc(a);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556         header() = <span class="keyword">reinterpret_cast&lt;</span>header_t*<span class="keyword">&gt;</span>(alloc.allocate(<span class="keyword">sizeof</span>(header_t) - <span class="keyword">sizeof</span>(node_t)
<a name="l00557"></a>00557             + <span class="keyword">sizeof</span>(node_t) * n));
<a name="l00558"></a>00558         header()-&gt;capacity() = n;
<a name="l00559"></a>00559         header()-&gt;size() = 0;
<a name="l00560"></a>00560         <a class="code" href="namespaceadobe.html#a2983facbc34f8d51a4e29b8965d4c661">construct</a>(&amp;header()-&gt;free_tail());
<a name="l00561"></a>00561         <a class="code" href="namespaceadobe.html#a2983facbc34f8d51a4e29b8965d4c661">construct</a>(&amp;header()-&gt;used_tail());
<a name="l00562"></a>00562         <a class="code" href="namespaceadobe.html#a2983facbc34f8d51a4e29b8965d4c661">construct</a>(&amp;header()-&gt;allocator(), a);
<a name="l00563"></a>00563 
<a name="l00564"></a>00564         node_t* prior = header()-&gt;free_tail().address();
<a name="l00565"></a>00565         <span class="keywordflow">for</span> (node_ptr first(&amp;header()-&gt;storage_m[0]), last(&amp;header()-&gt;storage_m[0]+ n);
<a name="l00566"></a>00566                 first != last; ++first)
<a name="l00567"></a>00567         {
<a name="l00568"></a>00568             set_next_raw(*prior, *first);
<a name="l00569"></a>00569             prior = first;
<a name="l00570"></a>00570             <span class="comment">// first-&gt;set_state(state_free);</span>
<a name="l00571"></a>00571         }
<a name="l00572"></a>00572         set_next_raw(*prior, header()-&gt;free_tail());
<a name="l00573"></a>00573 
<a name="l00574"></a>00574     }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     iterator bucket(<span class="keyword">const</span> <a class="code" href="namespaceadobe.html#a0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)
<a name="l00577"></a>00577     {
<a name="l00578"></a>00578         std::size_t slot(hash_function()(key) % capacity());
<a name="l00579"></a>00579         <span class="keywordflow">return</span> iterator(&amp;header()-&gt;storage_m[0] + slot);
<a name="l00580"></a>00580     }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582     iterator <a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(iterator node, <span class="keyword">const</span> <a class="code" href="namespaceadobe.html#a0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)
<a name="l00583"></a>00583     {
<a name="l00584"></a>00584         <span class="keywordflow">do</span>
<a name="l00585"></a>00585         {
<a name="l00586"></a>00586             <span class="keywordflow">if</span> (key_eq()(key, key_function()(*node))) <span class="keywordflow">return</span> node;
<a name="l00587"></a>00587             ++node;
<a name="l00588"></a>00588         } <span class="keywordflow">while</span> ((node != end()) &amp;&amp; (node.state() != std::size_t(state_home)));
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         <span class="keywordflow">return</span> end();
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     <span class="comment">// location points to a free node</span>
<a name="l00594"></a>00594     <span class="keyword">static</span> <span class="keywordtype">void</span> insert_raw(iterator location, value_type x, std::size_t state)
<a name="l00595"></a>00595     {
<a name="l00596"></a>00596         construct&lt;value_type&gt;(&amp;*location, <a class="code" href="group__move__related.html#ga19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor. This call, with the help of the return value optimization, will cause x to be moved instead of copied to its destination. See adobe/test/move/main.cpp for examples.">adobe::move</a>(x));
<a name="l00597"></a>00597         location.set_state(state);
<a name="l00598"></a>00598         <a class="code" href="group__adobe__iterator.html#ga3adeba343a28c39563dc4aae37f22421">unsafe::skip_node</a>(location);
<a name="l00599"></a>00599     }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601     <span class="comment">// location points to a used but detatched node</span>
<a name="l00602"></a>00602     <span class="keywordtype">void</span> erase_raw(iterator location)
<a name="l00603"></a>00603     {
<a name="l00604"></a>00604         <a class="code" href="namespaceadobe.html#a5552b0f660612c91fd30793df8d06091">destroy</a>(&amp;*location);
<a name="l00605"></a>00605         location.set_state(state_free);
<a name="l00606"></a>00606         <a class="code" href="group__adobe__iterator.html#ga38d33c4c128cae32602cefd55503a6d2">unsafe::splice_node_range</a>(end_free(), location, location);
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     iterator begin_free() { <span class="keywordflow">return</span> iterator(header() ? header()-&gt;free_tail().next() : 0); }
<a name="l00610"></a>00610     iterator end_free() { <span class="keywordflow">return</span> iterator(header() ? header()-&gt;free_tail().address() : 0); }
<a name="l00611"></a>00611 };
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="comment">/*************************************************************************************************/</span>
<a name="l00614"></a>00614 
<a name="l00633"></a>00633 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key,
<a name="l00634"></a>00634          <span class="keyword">typename</span> T,
<a name="l00635"></a>00635          <span class="keyword">typename</span> Hash,
<a name="l00636"></a>00636          <span class="keyword">typename</span> Pred,
<a name="l00637"></a>00637          <span class="keyword">typename</span> A&gt;
<a name="l00638"></a><a class="code" href="classadobe_1_1closed__hash__map.html">00638</a> <span class="keyword">class </span><a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a> : <span class="keyword">public</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&lt;pair&lt;Key, T&gt;,
<a name="l00639"></a>00639                                                get_element&lt;0, pair&lt;Key, T&gt; &gt;,
<a name="l00640"></a>00640                                                Hash,
<a name="l00641"></a>00641                                                Pred,
<a name="l00642"></a>00642                                                A&gt;
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644     <span class="keyword">typedef</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set&lt;pair&lt;Key, T&gt;</a>,
<a name="l00645"></a>00645                             <a class="code" href="structadobe_1_1get__element.html">get_element&lt;0, pair&lt;Key, T&gt;</a> &gt;,
<a name="l00646"></a>00646                             Hash,
<a name="l00647"></a>00647                             Pred,
<a name="l00648"></a>00648                             A&gt; <a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>;
<a name="l00649"></a>00649  <span class="keyword">public</span>:
<a name="l00650"></a><a class="code" href="classadobe_1_1closed__hash__map.html#a818fd380a9a028f2447a0410086e0d5a">00650</a>     <span class="keyword">typedef</span> T <a class="code" href="classadobe_1_1closed__hash__map.html#a818fd380a9a028f2447a0410086e0d5a">mapped_type</a>;
<a name="l00651"></a>00651 
<a name="l00652"></a><a class="code" href="classadobe_1_1closed__hash__map.html#ad3c2e1056e5bd90c8883f1411b0c63f5">00652</a>     <a class="code" href="classadobe_1_1closed__hash__map.html#ad3c2e1056e5bd90c8883f1411b0c63f5">closed_hash_map</a>() { }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models InputIterator</span>
<a name="l00655"></a><a class="code" href="classadobe_1_1closed__hash__map.html#a2f72f6d51949931b7ad4df1c4ddd338d">00655</a>     <a class="code" href="classadobe_1_1closed__hash__map.html#a2f72f6d51949931b7ad4df1c4ddd338d">closed_hash_map</a>(I f, I l) : <a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>(f, l) { }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 <span class="preprocessor">#if 0</span>
<a name="l00658"></a>00658 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models ForwardIterator</span>
<a name="l00659"></a>00659     <a class="code" href="namespaceadobe.html#a07e1ab8f8ec0603377b4d89bfa9b9bae">closed_hash_map</a>(I f, I l, move_ctor) : set_type(f, l, move_ctor()) { }
<a name="l00660"></a>00660 <span class="preprocessor">#endif</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span>
<a name="l00662"></a><a class="code" href="classadobe_1_1closed__hash__map.html#a09fc6de1695ae65f7fd182ef6609aad2">00662</a>     <a class="code" href="classadobe_1_1closed__hash__map.html#a09fc6de1695ae65f7fd182ef6609aad2">closed_hash_map</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; x) : <a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>(x) { }
<a name="l00663"></a><a class="code" href="classadobe_1_1closed__hash__map.html#a01ebdafce2e5d9acadad763521f0df8f">00663</a>     <a class="code" href="classadobe_1_1closed__hash__map.html#a01ebdafce2e5d9acadad763521f0df8f">closed_hash_map</a>(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from&lt;closed_hash_map&gt;</a> x) : <a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from</a>&lt;<a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>&gt;(x.source)) { }
<a name="l00664"></a><a class="code" href="classadobe_1_1closed__hash__map.html#ae840c11fac3bbec9dbe0c01042ae0ffe">00664</a>     <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; operator=(<a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a> x)
<a name="l00665"></a>00665     { <a class="code" href="namespaceadobe.html#a5c6656b2ba51d81c71a97670f3b15a83">swap</a>(x, *<span class="keyword">this</span>); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00666"></a>00666 
<a name="l00667"></a><a class="code" href="classadobe_1_1closed__hash__map.html#ae987b563c2c9de12da41af5fd1772bd5">00667</a>     <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="namespaceadobe.html#a5c6656b2ba51d81c71a97670f3b15a83">swap</a>(<a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; x, <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; y)
<a name="l00668"></a>00668     { <a class="code" href="classadobe_1_1closed__hash__map.html#ae987b563c2c9de12da41af5fd1772bd5">swap</a>(static_cast&lt;set_type&amp;&gt;(x), static_cast&lt;set_type&amp;&gt;(y)); }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 
<a name="l00671"></a><a class="code" href="classadobe_1_1closed__hash__map.html#aad4363c6218148569be71f78b81df94e">00671</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceadobe.html#aa70510cd533bc8e226d58fc472ca1f6b">operator==</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; y)
<a name="l00672"></a>00672     { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>&amp;<span class="keyword">&gt;</span>(x) == static_cast&lt;const set_type&amp;&gt;(y); }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     <span class="comment">/*</span>
<a name="l00675"></a>00675 <span class="comment">        NOTE (sparent) : Can&#39;t use boost::equality_comparable without introducing extra base class</span>
<a name="l00676"></a>00676 <span class="comment">        overhead.</span>
<a name="l00677"></a>00677 <span class="comment">    */</span>
<a name="l00678"></a>00678 
<a name="l00679"></a><a class="code" href="classadobe_1_1closed__hash__map.html#a1641788f2d13e2e0dcf1f30daa97a7e8">00679</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceadobe.html#a1048ea807626add40ae9a2800c1b6a5f">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; y)
<a name="l00680"></a>00680     { <span class="keywordflow">return</span> !(x == y); }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="preprocessor">#ifndef ADOBE_CLOSED_HASH_MAP_INDEX</span>
<a name="l00683"></a><a class="code" href="closed__hash_8hpp.html#a98bd3002bce0c0babe79b0cf52869936">00683</a> <span class="preprocessor"></span><span class="preprocessor">#define ADOBE_CLOSED_HASH_MAP_INDEX 1</span>
<a name="l00684"></a>00684 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00685"></a>00685 <span class="preprocessor"></span>
<a name="l00686"></a>00686 <span class="preprocessor">#if ADOBE_CLOSED_HASH_MAP_INDEX</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span>
<a name="l00688"></a><a class="code" href="classadobe_1_1closed__hash__map.html#a46d61d9c198c63e2a750811e839e506f">00688</a>     <a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">mapped_type</a>&amp; operator[](<span class="keyword">const</span> Key&amp; x)
<a name="l00689"></a>00689     {
<a name="l00690"></a>00690         <span class="keyword">typename</span> <a class="code" href="classadobe_1_1closed__hash__set.html#aa9317c7f86e5fbf136dfeddeb2fb0d50">set_type::iterator</a> i = this-&gt;<a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(x);
<a name="l00691"></a>00691         <span class="keywordflow">if</span> (i == this-&gt;end()) <span class="keywordflow">return</span> <a class="code" href="group__sequence__model__concept.html#gaea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="group__asl__pair.html#ga86cec50e4c5771ecd54930cc50dedcfd">adobe::make_pair</a>(x, <a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">mapped_type</a>())).first-&gt;second;
<a name="l00692"></a>00692         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695 <span class="preprocessor">#endif</span>
<a name="l00696"></a>00696 <span class="preprocessor"></span>};
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 <span class="comment">/*************************************************************************************************/</span>
<a name="l00699"></a>00699 
<a name="l00700"></a>00700 <a class="code" href="namespaceadobe.html#a0d19002ca08b6fc1baf4fad3522925c3">BOOST_STATIC_ASSERT</a>(<span class="keyword">sizeof</span>(closed_hash_set&lt;int&gt;) == <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00701"></a>00701 
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 <span class="preprocessor">#ifndef ADOBE_NO_DOCUMENTATION</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span>
<a name="l00705"></a>00705 } <span class="comment">// namespace version_1</span>
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 <span class="preprocessor">#endif</span>
<a name="l00708"></a>00708 <span class="preprocessor"></span>
<a name="l00709"></a>00709 <span class="comment">/*************************************************************************************************/</span>
<a name="l00710"></a>00710 
<a name="l00711"></a>00711 } <span class="comment">// namespace adobe</span>
<a name="l00712"></a>00712 
<a name="l00713"></a>00713 <span class="comment">/*************************************************************************************************/</span>
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 <a class="code" href="group__type__info__related.html#gac7fc230df70a262b176a5c198a265c55" title="Register a type for use with manual adobe::version_1::type_info_t . This integer indicates the number...">ADOBE_NAME_TYPE_1</a>(<span class="stringliteral">&quot;closed_hash_set:version_1:adobe&quot;</span>,
<a name="l00716"></a>00716     <a class="code" href="group__abi__container.html#ga123a2e265d9c35109e121cb70b865f18">adobe::version_1::closed_hash_set</a>&lt;T0, <a class="code" href="structadobe_1_1identity.html">adobe::identity&lt;const T0&gt;</a>, boost::hash&lt;T0&gt;, std::equal_to&lt;T0&gt;,
<a name="l00717"></a>00717         <a class="code" href="classadobe_1_1version__1_1_1capture__allocator.html">adobe::capture_allocator&lt;T0&gt;</a> &gt;);
<a name="l00718"></a>00718 <a class="code" href="closed__hash_8hpp.html#a9a5edc61c538379dfaad83c1b20337ca">ADOBE_NAME_TYPE_2</a>(<span class="stringliteral">&quot;closed_hash_map:version_1:adobe&quot;</span>,
<a name="l00719"></a>00719     <a class="code" href="namespaceadobe.html#a07e1ab8f8ec0603377b4d89bfa9b9bae">adobe::version_1::closed_hash_map</a>&lt;T0, T1, boost::hash&lt;T0&gt;, std::equal_to&lt;T0&gt;,
<a name="l00720"></a>00720             <a class="code" href="classadobe_1_1version__1_1_1capture__allocator.html">adobe::capture_allocator</a>&lt;<a class="code" href="structadobe_1_1pair.html">adobe::pair&lt;T0, T1&gt;</a> &gt; &gt;);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <a class="code" href="group__type__info__related.html#ga78080b90cf4dc9ee58a0f15b8c1fdd67" title="Register a type for use with manual adobe::version_1::type_info_t . This integer indicates the number...">ADOBE_NAME_TYPE_5</a>(<span class="stringliteral">&quot;closed_hash_set:version_1:adobe&quot;</span>,
<a name="l00723"></a>00723     adobe::version_1::closed_hash_set&lt;T0, T1, T2, T3, T4 &gt;);
<a name="l00724"></a>00724 <a class="code" href="group__type__info__related.html#ga78080b90cf4dc9ee58a0f15b8c1fdd67" title="Register a type for use with manual adobe::version_1::type_info_t . This integer indicates the number...">ADOBE_NAME_TYPE_5</a>(<span class="stringliteral">&quot;closed_hash_map:version_1:adobe&quot;</span>,
<a name="l00725"></a>00725     adobe::version_1::closed_hash_map&lt;T0, T1, T2, T3, T4 &gt;);
<a name="l00726"></a>00726 
<a name="l00727"></a>00727 <span class="comment">/*************************************************************************************************/</span>
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 <span class="keyword">namespace </span>boost {
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 <span class="keyword">template</span>&lt;   <span class="keyword">typename</span> T,
<a name="l00732"></a>00732             <span class="keyword">typename</span> KeyTransform,
<a name="l00733"></a>00733             <span class="keyword">typename</span> Hash,
<a name="l00734"></a>00734             <span class="keyword">typename</span> Pred,
<a name="l00735"></a>00735             <span class="keyword">typename</span> A&gt;
<a name="l00736"></a><a class="code" href="structboost_1_1has__nothrow__constructor_3_01adobe_1_1version__1_1_1closed__hash__set_3_01T_00_00cbb81074f838e5f10556d135efe1cf8.html">00736</a> <span class="keyword">struct </span>has_nothrow_constructor&lt;adobe::version_1::<a class="code" href="group__abi__container.html#ga123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>&lt;T, KeyTransform, Hash, Pred, A&gt; &gt;
<a name="l00737"></a>00737         : boost::mpl::true_ { };
<a name="l00738"></a>00738 
<a name="l00739"></a>00739 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key,
<a name="l00740"></a>00740          <span class="keyword">typename</span> T,
<a name="l00741"></a>00741          <span class="keyword">typename</span> Hash,
<a name="l00742"></a>00742          <span class="keyword">typename</span> Pred,
<a name="l00743"></a>00743          <span class="keyword">typename</span> A&gt;
<a name="l00744"></a><a class="code" href="structboost_1_1has__nothrow__constructor_3_01adobe_1_1version__1_1_1closed__hash__map_3_01Key_008b22857affbb01c8b29547d7855d52f1.html">00744</a> <span class="keyword">struct </span>has_nothrow_constructor&lt;adobe::version_1::<a class="code" href="namespaceadobe.html#a07e1ab8f8ec0603377b4d89bfa9b9bae">closed_hash_map</a>&lt;Key, T, Hash, Pred, A&gt; &gt;
<a name="l00745"></a>00745     : boost::mpl::true_ { };
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 } <span class="comment">// namespace boost</span>
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 <span class="comment">/*************************************************************************************************/</span>
<a name="l00750"></a>00750 
<a name="l00751"></a>00751 <span class="preprocessor">#endif</span>
<a name="l00752"></a>00752 <span class="preprocessor"></span>
<a name="l00753"></a>00753 <span class="comment">/*************************************************************************************************/</span>
</pre></div></div>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
