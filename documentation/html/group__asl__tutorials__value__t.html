<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: any_regular_t</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="http://sourceforge.net/adobe/">Open @ Adobe</a><br/>
        <a href="http://opensource.adobe.com/">Adobe Open Source</a><br/>
        <a href="http://labs.adobe.com/">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.7.2 -->
<div class="header">
  <div class="headertitle">
<h1>any_regular_t<br/>
<small>
[<a class="el" href="group__asl__tutorials.html">ASL Tutorials</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
</table>
<p><em>Last updated November 2, 2006</em></p>
<h2><a class="anchor" id="value_t_background"></a>
Background</h2>
<h3><a class="anchor" id="background_discriminated_types"></a>
Discriminated Types and Unions</h3>
<dl class="user"><dt><b></b></dt><dd>adobe::any_regular_t is a pseudo-discriminated union. Before we can go any further we must first understand what a discriminated type is. Kevin Henney best describes discriminated types in his documentation of <a href="http://www.boost.org/doc/html/any.html#id447427">boost::any</a>:<ul>
<li><em>Discriminated types ... contain values of different types but do not attempt conversion between them, i.e. <code>5</code> is held strictly as an <code>int</code> and is not implicitly convertible either to <code>"5"</code> or to <code>5.0</code>. Their indifference to interpretation but awareness of type effectively makes them safe, generic containers of single values, with no scope for surprises from ambiguous conversions.</em> </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>A discriminated union, then, is a type that can retain any one of a collection of discriminated types, but then only one at a time. In the case of adobe::any_regular_t its storable type range is limited to any type modeling the <a class="el" href="group__asl__tutorials__value__t.html#background_data_type_requirements">Data Type Concept Requirements</a>.</dd></dl>
<h4><a class="anchor" id="discriminated_types_similarities"></a>
Similarities</h4>
<dl class="user"><dt><b></b></dt><dd>adobe::any_regular_t being a discriminated union means it is capable of holding any of: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a>  my_int(5);
<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a>  my_string(std::string(<span class="stringliteral">&quot;Hello, world!&quot;</span>));
<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a>  my_whizzy_class(whizzy_class(<span class="comment">/*...*/</span>));
<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a>  my_some_other_regular_type(<span class="comment">/*...*/</span>);
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An adobe::any_regular_t may also store a different type of data at different points in time: for example it can start out storing 'nothing': </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_value; <span class="comment">// my_value now holds adobe::empty_t</span>
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>... then store a std::string at a later time: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">my_value = std::string(<span class="stringliteral">&quot;Hello, world!&quot;</span>); <span class="comment">// my_value now holds a std::string</span>
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>... then store another arbitrary data type even later: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">my_value = my_whizzy_class; <span class="comment">// adobe::any_regular_t to adobe::any_regular_t assignments are OK</span>
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that in the last case the type stored within <code>my_value</code> is not adobe::any_regular_t, but the type stored within the adobe::any_regular_t from which it was assigned. In the case above, <code>my_value</code> now retains data of type <code>whizzy_class</code> because <code>my_whizzy_class</code> stored data of that type.</dd></dl>
<h4><a class="anchor" id="discriminated_types_differences"></a>
Differences</h4>
<dl class="user"><dt><b>Type Promotion</b></dt><dd>Unless otherwise specified, adobe::any_regular_t makes no attempt to store data in any other than its original type. (This follows the behavior of a discriminated union). However it is possible to specify an explicit coersion from one data type to another. In order to ensure preservation of data the coersion should always be from a type of smaller resolution to one of greater resolution. That is to say there should be no data loss during the type coersion. This restricted type conversion is thus called <em>type promotion</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>adobe::any_regular_t takes advantage of type promotion to allow for an explicit, well-defined means of converting values between different types. adobe::any_regular_t uses <a class="el" href="structadobe_1_1promote.html" title="A struct for compile-time type promotion.">adobe::promote</a> to accomplish type promotion. For a data type passed, <a class="el" href="structadobe_1_1promote.html" title="A struct for compile-time type promotion.">adobe::promote</a> specifies its promoted data type. By default this is merely the original type itself (i.e., no coersion takes place): </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct </span>promote
{
    <span class="keyword">typedef</span> T type; <span class="comment">// promote&lt;T&gt;::type is, by default, T</span>
};
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is possible to specialize <a class="el" href="structadobe_1_1promote.html" title="A struct for compile-time type promotion.">adobe::promote</a> for any type, specifying an alternate type for coersion: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct </span>promote&lt;int&gt;
{
    <span class="keyword">typedef</span> <span class="keywordtype">double</span> type; <span class="comment">// promote&lt;int&gt;::type is now a double</span>
};
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note the restriction specified above (that one should only coerce from a "smaller" to a "bigger" type) is not enforced at either compile time or runtime: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct </span>promote&lt;double&gt;
{
    <span class="keyword">typedef</span> <span class="keywordtype">int</span> type; <span class="comment">// Legal, but bad: possible data loss</span>
};
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Therefore you should be very carfeul when specifying your own type promotions. In general it is not necessary to do so. By default there are several type promotions already defined: see the documentation for <a class="el" href="structadobe_1_1promote.html" title="A struct for compile-time type promotion.">adobe::promote</a> for more information. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Whenever data is stored in a adobe::any_regular_t, it is always type-promoted before storage. Similarly, when a data is retrieved from a adobe::any_regular_t the data is "type-demoted" to the requested type at the time of the retrieval. If the requested type is not specified to be promoted to the stored type, an exception is thrown (more on this later.)</dd></dl>
<h3><a class="anchor" id="background_data_type_requirements"></a>
Data Type Concept Requirements</h3>
<dl class="user"><dt><b></b></dt><dd>In order for adobe::any_regular_t to be assigned from a given type and value, the type must model the concept of a <a class="el" href="group__concept__regular__type.html">Regular</a>. All built-in data types model this concept, as do many of the classes found in both the STL and the ASL. adobe::any_regular_t may store any user-defined data type as well, as long as that data type is a model of <a class="el" href="group__concept__regular__type.html">Regular</a>.</dd></dl>
<h2><a class="anchor" id="value_t_usage"></a>
Usage</h2>
<h3><a class="anchor" id="usage_initialization_and_storage"></a>
Initialization and Storage</h3>
<dl class="user"><dt><b></b></dt><dd>As we have seen in some of the previous examples, using adobe::any_regular_t is pretty straightforward. adobe::any_regular_t can be constructed with anything that is a <a class="el" href="group__concept__regular__type.html">Regular</a>, including default construction: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_empty_value;
<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_int_value(5);
<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_other_int_value(my_int_value);
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As mentioned above, the last adobe::any_regular_t in this code snippet inherits the data type from the adobe::any_regular_t from which it was assigned; adobe::any_regular_t's cannot be directly nested. They can, however, be indirectly nested: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> std::vector&lt;adobe::any_regular_t&gt; my_vector_value_type;

    my_vector_value_type my_vector_value;

    my_vector_value.push_back(<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a>(5));
    my_vector_value.push_back(<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a>(<span class="charliteral">&#39;A&#39;</span>));
    my_vector_value.push_back(<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a>(std::string(<span class="stringliteral">&quot;hello, world!&quot;</span>));

    <a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_vector_value_value(my_vector_value);
</pre></div></dd></dl>
<h3><a class="anchor" id="usage_query"></a>
Data Type Querying</h3>
<dl class="user"><dt><b></b></dt><dd>It is possible to check the type of data stored within an adobe::any_regular_t with <code>type()</code>: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_value(std::string(<span class="stringliteral">&quot;hello, world!&quot;</span>));

<span class="comment">// ...</span>

<span class="keywordflow">if</span> (my_value.type() == <span class="keyword">typeid</span>(std::string))
{
    <span class="comment">// ... </span>
}
<span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_value.type() == <span class="keyword">typeid</span>(double))
{
    <span class="comment">// ...</span>
}
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that when checking for the type contained within the adobe::any_regular_t, you want to check it against the promoted data type, not the data type from which the adobe::any_regular_t was assigned: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_int_value(5);

<span class="keywordflow">if</span> (my_int_value.type() == <span class="keyword">typeid</span>(int))
{
    <span class="comment">// not here!</span>
}
<span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_int_value.type() == <span class="keyword">typeid</span>(double))
{
    <span class="comment">// you&#39;ll end up in here</span>
}
</pre></div></dd></dl>
<h3><a class="anchor" id="usage_retrieval"></a>
Retrieval</h3>
<dl class="user"><dt><b></b></dt><dd>Data is extracted from the adobe::any_regular_t by means of <a class="el" href="classadobe_1_1version__1_1_1any__regular__t.html#af0b973612bd860b1e3172c60d57ac3e3">adobe::any_regular_t::cast&lt;&gt;</a>: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_value(5);

<span class="comment">// ...</span>

<span class="keywordtype">double</span> my_double(my_value.<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html#af0b973612bd860b1e3172c60d57ac3e3">cast</a>&lt;<span class="keywordtype">double</span>&gt;()); <span class="comment">// my_double now contains 5.0</span>
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note in the above example the type conversion is legal because <a class="el" href="structadobe_1_1promote.html" title="A struct for compile-time type promotion.">adobe::promote</a> explicitly allows it. Value retrieval can be serialized in the case when one has indirectly nested adobe::any_regular_t instances. Here is an example using <code>my_vector_value</code> from above: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> my_char = my_vector_value_value.cast&lt;my_vector_value_type&gt;()[1].<span class="keyword">template</span> cast&lt;char&gt;();
<span class="comment">// my_char now contains &#39;A&#39;</span>
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the requested data type does not match the stored data type, and if the stored data type is not the promoted type of the requested data type, <a class="el" href="classadobe_1_1version__1_1_1any__regular__t.html#af0b973612bd860b1e3172c60d57ac3e3">adobe::any_regular_t::cast&lt;&gt;</a> will throw an exception: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_value(std::string(<span class="stringliteral">&quot;hello, world!&quot;</span>));

<span class="keywordflow">try</span>
{
    <span class="keywordtype">int</span> x = my_value.<a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html#af0b973612bd860b1e3172c60d57ac3e3">cast</a>&lt;<span class="keywordtype">int</span>&gt;();
}
<span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; err)
{
    std::cerr &lt;&lt; err.what() &lt;&lt; std::endl;
}
<span class="keywordflow">catch</span>(...)
{
    std::cerr &lt;&lt; <span class="stringliteral">&quot;don&#39;t know what happened!&quot;</span> &lt;&lt; std::endl;
}
</pre></div></dd></dl>
<h2><a class="anchor" id="value_t_experimental_features"></a>
Experimental Features</h2>
<h3><a class="anchor" id="experimental_features_serialization"></a>
Serialization</h3>
<dl class="user"><dt><b></b></dt><dd>It is possible to extend adobe::any_regular_t's functionality in such a way that the contained data can be serialized from within adobe::any_regular_t. This is activated by defining a macro: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="preprocessor">#define ADOBE_SERIALIZATION</span>
</pre></div> When this code is enabled, the data type requirements of adobe::any_regular_t are extended: now the elements must not only be a model of the <a class="el" href="group__concept__regular__type.html">Regular</a> concept, but they must also have <code>operator &lt;&lt;</code> defined for them to allow for the serialization of their value to a stream. Note this is true whether or not you ever serialize an adobe::any_regular_t with a particular type. Note too that this is only for output streams, not input streams. With the macro defined one now has the ability to serialize adobe::any_regular_t: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="preprocessor">#define ADOBE_SERIALIZATION</span>
<span class="preprocessor"></span>
<span class="comment">// include adobe/value.hpp at some point</span>

<span class="keywordtype">int</span> main(<span class="comment">/*...*/</span>)
{
    <a class="code" href="classadobe_1_1version__1_1_1any__regular__t.html" title="A runtime polymorphic type similar to boost::any which can hold any type which models Regular...">adobe::any_regular_t</a> my_value(std::string(<span class="stringliteral">&quot;Hello, world!&quot;</span>);

    std::cout &lt;&lt; my_value &lt;&lt; std::endl; <span class="comment">// Prints &quot;Hello, world!&quot;</span>

    <span class="keywordflow">return</span> 0;
}
</pre></div> </dd></dl>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
