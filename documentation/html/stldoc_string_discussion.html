<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: string_discussion</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="http://sourceforge.net/adobe/">Open @ Adobe</a><br/>
        <a href="http://opensource.adobe.com/">Adobe Open Source</a><br/>
        <a href="http://labs.adobe.com/">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.7.2 -->
<div class="header">
  <div class="headertitle">
<h1>string_discussion </h1>  </div>
</div>
<div class="contents">
<h1>Strings in SGI STL </h1>
<p>This is an attempt to answer some of the questions related to the use of strings with SGI STL.</p>
<h2>What's wrong with the string class defined by the draft standard? </h2>
<p>There are several problems, but the most serious ones relate to the specification for lifetimes of references to characters in a string. The second committee draft disallows the expression <code>s[1] == s[2]</code> where s is a nonconstant string. This is not simply an oversight; current reference counted implementations may fail for more complicated examples. They may fail even for <code>s[1] == s[2]</code> if the string <code>s</code> is simultaneously examined (merely examined, not necessarily modified) by another thread. It is hard to define precisely what constitutes a correct use of one of the current reference counted implementation. </p>
<p>This problem was partially addressed at the July 1997 meeting of the C++ standardization committee; the solution was to adopt more complicated rules about reference lifetimes. Unfortunately, these new rules still do not address the multi-threading issues. </p>
<p>A related problem was pointed out in the French national body comments on the second committee draft. The following program produces the wrong answer for most reference counted <code>basic_string</code> implementations that we have tested; the problem is that, if two strings share a common representation, they are vulnerable to modification through a pre-existing reference or iterator. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># include &lt;string&gt;</span>
<span class="preprocessor"># include &lt;stdio.h&gt;</span>

main() {
   <span class="keywordtype">string</span> s(<span class="stringliteral">&quot;abc&quot;</span>);
   <span class="keywordtype">string</span> t;
   <span class="keywordtype">char</span> &amp;amp c(s[1]);

   t = s;   <span class="comment">// Data typically shared between s and t.</span>
   c = <span class="charliteral">&#39;z&#39;</span>;     <span class="comment">// How many strings does this modify?</span>
   <span class="keywordflow">if</span> (t[1] == <span class="charliteral">&#39;z&#39;</span>) {
        printf(<span class="stringliteral">&quot;wrong\n&quot;</span>);
   } <span class="keywordflow">else</span> {
        printf(<span class="stringliteral">&quot;right\n&quot;</span>);
   }
}
</pre></div> <p>The draft standard (as well as common sense) says that updating a reference to one of <code>s</code>'s elements should only modify <code>s</code>, not <code>t</code> as well; the fact that <code>s</code> and <code>t</code> might share a representation is an implementation detail that should have no effect on program behavior. Given the design of <code>basic_string</code>, though, it is very difficult for a reference-counted implementation to satisfy that requirement. </p>
<p>The only known way for a reference-counted implementation to avoid this problem is to mark a string as unsharable whenever there might be an existing reference or iterator to that string. That is, whenever a program obtains a reference or an iterator to a string (<em>e.g.</em> by using <code>operator[]</code> or <code>begin()</code>), that particular string will no longer use reference counting; assignment and copy construction will copy the string's elements instead of just copying a pointer. (We are not aware of any implementation that uses this technique and that also attempts to be thread-safe.) </p>
<p>This is a drastic solution: since almost all ways of referring to characters involve references or iterators, this solution implies, in effect, that the only strings that can be reference-counted are the ones that are never used. In practice, then, a reference counted implementation of <code>basic_string</code> can't achieve the performance gains that one might otherwise expect, since reference counting is forbidden in all but a few special cases. </p>
<p>A different solution is to abandon the goal of reference-counted strings altogether, and to provide a non-reference-counted implementation of <code>basic_string</code> instead. The draft standard permits non-reference-counted implementations, and several vendors already provide them. The performance characteristics of a non-reference-counted <code>basic_string</code> are predicable, and are very similar to those of a <code>vector&amp;ltchar&amp;gt</code>: copying a string, for example, is always an <em>O(N)</em> operation. </p>
<p>In this implementation, <a class="el" href="stldoc_basic_string.html">basic_string</a> does not use reference counting.</p>
<h2>I have been using a reference counted implementation, and it works fine. Why haven't I seen problems? </h2>
<p>The current implementations do work correctly, most of the time: preserving a reference to a character in a string is uncommon. (Although preserving iterators to strings may be more frequent, and exactly the same issues apply to iterators.) Some less contrived sequential programs also fail, though, or else behave differently on different platforms. </p>
<p>Multi-threaded applications that use a reference counted <code>basic_string</code> are likely to fail intermittently, perhaps once every few months; these intermittent failures are difficult to reproduce and debug. But it is likely that a large fraction of multi-threaded clients will fail occasionally, thus making such a library completely inappropriate for multi-threaded use.</p>
<h2>So what should I use to represent strings? </h2>
<p>There are several possible options, which are appropriate under different circumstances: </p>
<dl>
<dt><b><a class="el" href="stldoc_Rope.html">Rope</a></b> </dt>
<dd><p class="startdd">Use the <code><a class="el" href="stldoc_Rope.html">Rope</a></code> package provided by the SGI STL. This provides all functionality that's likely to be needed. Its interface is similar to the current draft standard, but different enough to allow a correct and thread-safe implementation. It should perform reasonably well for all applications that do not require very frequent small updates to strings. It is the only alternative that scales well to very long strings, <em>i.e.</em> that could easily be used to represent a mail message or a text file as a single string. </p>
<p class="enddd">The disadvantages are: </p>
<ul>
<li>
Single character replacements are slow. Consequently STL algorithms are likely to be slow when updating ropes. (Insertions near the beginning take roughly the same amount of time as single character replacements, and much less time than corresponding insertions for the other string alternatives.) </li>
<li>
The <code><a class="el" href="stldoc_Rope.html">Rope</a></code> implementation stretches current compiler technology. Portability and compilation time may be an issue in the short term. Pthread performance on non-SGI platforms will be an issue until someone provides machine-specific fast reference counting code. (This is also likely to be an issue for other reference counted implementations.) </li>
</ul>
</dd>
<dt><b>C strings</b> </dt>
<dd>This is likely to be the most efficient way to represent a large collection of very short strings. It is by far the most space efficient alternative for small strings. For short strings, the C library functions in <code>&lt;string.h&gt;</code> provide an efficient set of tools for manipulating such strings. They allow easy communication with the C library. The primary disadvantages are that <ul>
<li>
Operations such as concatenation and substring are much more expensive than for <code><a class="el" href="stldoc_Rope.html">Rope</a></code> if the strings are long. A C string is not a good representation for a text file in an editor. </li>
<li>
The user needs to be aware of sharing between string representations. If strings are assigned by copying pointers, an update to one string may affect another. </li>
<li>
C strings provide no help in storage management. This may be a major issue, although a garbage collector can help alleviate it. </li>
</ul>
</dd>
<dt><b><a class="el" href="stldoc_Vector.html">Vector</a>&lt;char&gt;</b> </dt>
<dd><p class="startdd">If a string is treated primarily as an array of characters, with frequent in-place updates, it is reasonable to represent it as <code><a href="Vector.html">vector</a>&lt;char&gt;</code> or <code><a href="Vector.html">vector</a>&lt;wchar_t&gt;</code>. The same is true if it will be modified by STL container algorithms. Unlike C strings, vectors handle internal storage management automatically, and operations that modify the length of a string are generally more convenient. </p>
<p class="enddd">Disadvantages are: </p>
<ul>
<li>
Vector assignments are much more expensive than C string pointer assignments; the only way to share string representations is to pass pointers or references to vectors. </li>
<li>
Most operations on entire strings (<em>e.g.</em> assignment, concatenation) do not scale well to long strings. </li>
<li>
A number of standard string operations (<em>e.g.</em> concatenation and substring) are not provided with the usual syntax, and must be expressed using generic STL algorithms. This is usually not hard. </li>
<li>
Conversion to C strings is currently slow, even for short strings. That may change in future implementations. </li>
</ul>
</dd>
</dl>
<h2>What about <code>mstring.h</code>, as supplied with SGI's 7.1 compiler?</h2>
<p>This package was a minimal adaptation of the freely available Modena strings package. It was intended as a stopgap. We do not intend to develop it further. </p>
<p>It shares some of the reference lifetime problems of other implementations that try to conform to the draft standard. Its exact semantics were never well-defined. Under rare conditions, it will have unexpected semantics for single-threaded applications. It fails on the example given above. We strongly discourage use for multi-threaded applications. </p>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
