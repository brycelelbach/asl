<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: forest</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="http://sourceforge.net/adobe/">Open @ Adobe</a><br/>
        <a href="http://opensource.adobe.com/">Adobe Open Source</a><br/>
        <a href="http://labs.adobe.com/">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.7.2 -->
<div class="header">
  <div class="headertitle">
<h1>forest<br/>
<small>
[<a class="el" href="group__asl__tutorials.html">ASL Tutorials</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
</table>
<p><em>Last updated January 25, 2005</em></p>
<h2><a class="anchor" id="tutorials_forest_background"></a>
Background</h2>
<dl class="user"><dt><b></b></dt><dd>A forest is a node-based (bidirectional) data structure for the representation of a heirarchy. The parent/child relationship between the nodes is maintained in the container class, so any regular type can be stored within without affecting it. It is equipped with a host of powerful iterators for varied methods of traversing the heirarchy, each of which is described below.</dd></dl>
<h2><a class="anchor" id="tutorials_forest_usage"></a>
Usage</h2>
<h3><a class="anchor" id="forest_usage_empty"></a>
An Empty Forest</h3>
<dl class="user"><dt><b></b></dt><dd>The best way to describe the forest class and its iterators is visually. Here is what a forest with no nodes added to it looks like (an "empty" forest): </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="forest_empty.jpg" alt="forest_empty.jpg"/>
</div>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "forest" is simply the item you "hang on to" when you're creating forest nodes. Note that subtrees themselves, then, are not forests.</dd></dl>
<h3><a class="anchor" id="forest_usage_iteration"></a>
Forest Iteration</h3>
<dl class="user"><dt><b></b></dt><dd>Here's a simple forest with some nodes added: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="forest_simple.jpg" alt="forest_simple.jpg"/>
</div>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this figure we have a forest with three nodes. The red lines are the tree structure of the forest- node <code>A</code> connects to both nodes <code>B</code> and <code>C</code> as children. The blue dashed lines are the possible "positions" the <code>forest::iterator</code> will be over this forest. The best way to think of the <code>forest::iterators</code> is not so much the node that they point to but rather the nodes they "sit" in between. For instance, <code>forest::begin()</code> "sits" in between the forest head and node <code>A</code> in the above example.</dd></dl>
<h4><a class="anchor" id="usage_iteration_sample"></a>
A Sample Iteration</h4>
<dl class="user"><dt><b></b></dt><dd>To follow a forward fullorder iterator over the above example, we start between forest head and <code>A</code>. The iterator will then move onto node <code>B</code>, where something interesting happens. You'll see a "pivot" take place where the iterator doesn't actually move on from node <code>B</code> to <code>C</code>. Instead, it "changes edges", notably from the <em>leading</em> edge of node <code>B</code> to the <em>trailing</em> edge of <code>B</code>. The next step takes us to the leading edge of <code>C</code>, then another pivot to the trailing edge of <code>C</code>. The iterator will then move back up to <code>A</code>'s trailing edge, then to the top, <code>forest::end()</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Visiting a node twice in every iteration of a forest is <em>very</em> useful in the case of serialization of the forest data, especially to XML-based formats. Upon leading-edge arrival to the node you output the opening (&lt;&gt;) tag and upon trailing-edge arrival you output the closing (&lt;/&gt;) tag. Since the (sub)children are visited in between these two arrivals the output will be well-formed XML that perfectly describes the state and relationships of the forest nodes.</dd></dl>
<h4><a class="anchor" id="usage_iteration_types"></a>
forest::iterator Types</h4>
<dl class="user"><dt><b></b></dt><dd>There are several types of iterators available to <code><a class="el" href="classadobe_1_1forest.html" title="A homogeneous hierarchical structure class.">adobe::forest</a></code>. They are:<ul>
<li><b><code>forest::iterator</code></b>: (also known as the fullorder iterator.) Visits the nodes by &lt;parent&gt;&lt;children&gt;&lt;children&gt;&lt;parent&gt;. Each node in the forest is visted twice.</li>
<li><b><code>forest::preorder_iterator</code></b>: Visits the nodes by &lt;parent&gt;&lt;children&gt;. Each node in the forest is visted once.</li>
<li><b><code>forest::postorder_iterator</code></b>: Visits the nodes by &lt;children&gt;&lt;parent&gt;. Each node in the forest is visted once.</li>
<li><b><code>forest::child_iterator</code></b>: From any given node, <code>child_iterator</code> is a bidirectional iterator that walks a range of <em>siblings</em> (not the node's children) by "pivoting" on each node. There is a <code><a class="el" href="classadobe_1_1forest.html#a3207724ee5bb961f12733bc7d0cbe1a7">child_begin()</a></code> and <code><a class="el" href="classadobe_1_1forest.html#af2413ecad1bb8411b3d12fbec0449ffe">child_end()</a></code> function to give you a range for the children of any node. Thus the <code>child_iterator</code> only applies to the first level of siblings, not to grandchildren or beyond. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are also <code>reverse_</code> versions of the <code>fullorder</code> and <code>child</code> iterators, and <code>const_</code> versions of the <code>fullorder</code> and <code>child</code> iterators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that only the fullorder iterator and child iterator are guaranteed constant time for increment and decrement. Pre- and post-order are amortorized constant time for a full traversal, but any single increment could take up to <code>O(N)</code> where <code>N</code> is the number of nodes in the forest.</dd></dl>
<h3><a class="anchor" id="forest_usage_insertion"></a>
Node Insertion</h3>
<dl class="user"><dt><b></b></dt><dd>Consider the simple forest example above. Now let's say we wanted to insert a new node, <code>D</code>, somewhere around any given node in the tree (in this case we'll use node <code>A</code>). Given node <code>A</code> there are four distinct relationships <code>D</code> will have to <code>A</code> after insertion. The four possible relationships are:<ol type="1">
<li>As the previous sibling to <code>A</code>. Note the iterator is pointing to <code>A</code>.</li>
<li>As the next sibling to <code>A</code>. Note the iterator is pointing to <code>forest::end()</code>.</li>
<li>As the first child of <code>A</code>, or the previous sibling of <code>B</code>. Note the iterator is pointing to <code>B</code>.</li>
<li>As the last child of <code>A</code>, or the next sibling of <code>C</code>. Note the iterator is pointing to <code>A</code>. </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Observe that the last two relationships are similar to the first two. Consider this visual of the above situation: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="forest_insertion.jpg" alt="forest_insertion.jpg"/>
</div>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that for each of the four possibilities, the new node will be inserted along one of the dashed lines leading into or out of <code>A</code>. Don't forget that the dashed lines represent the position of any given iterator at any given time in the forest. In the case of a leaf node, the leading out and trailing in lines (iterator positions) are the same line (the loop), so the principle still applies. Insertion of nodes will always take place on top of one of these dashed lines, and never anywhere else. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>There is aninsert which takes a <code>[first, last)</code> sequence, allowing you to insert more than one node essentially at the same location. Doing so makes the inserted sequence all "siblinging" on the same arc. It is the same as if you inserted each item, <code>first</code> to <code>last - 1</code>, at the same location. So let's say I have a fullorder iterator to the leading edge of node <code>A</code> and I want to add a vector of items as children of <code>A</code>. One can write: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="comment">// move my iterator to exit the leading edge</span>
++iter;

<span class="comment">// add all of the vector as children of A.</span>
my_forest.insert(iter, my_vec.begin(), my_vec.end()); 
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Observe that if you did not do the initial <code>++iter</code> the vector's elements would be added before <code>A</code>, as siblings of <code>A</code>.</dd></dl>
<h3><a class="anchor" id="forest_usage_deletion"></a>
Node Deletion</h3>
<dl class="user"><dt><b></b></dt><dd>Deletion of nodes happens by the passing of two iterators. Nodes can only be deleted if they are leaf nodes. If the iterators encompass a range of nodes, the nodes will be deleted bottom-up, so they are always leaf nodes when they are deleted. The rule for the deletion of nodes is this: a node will be deleted if and only if the deletion iteration passes through the node <em>twice</em>. As an example consider the following diagrams: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="forest_deletion.jpg" alt="forest_deletion.jpg"/>
</div>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the first stage we have the iterators sitting between <code>A</code> and <code>B</code> and at <code>forest::end()</code>. The nodes <code>B</code> and <code>C</code> will be deleted because the iterator will go through both of those nodes twice while traversing from the start to the end of the deletion range. Note that even though the deletion iterator will pass through <code>A</code> it is not deleted because it only passes through once. Another way to think about it is if you were to "pinch" the forest with you fingers at the start and end of the range, and any node that isn't held back by the pinching at those two locations "drops" off the forest and is deleted. In the above case <code>A</code> would be dropped by one of the pinches but not the other, so it remains.</dd></dl>
<h2><a class="anchor" id="forest_tutorial_examples"></a>
Examples</h2>
<dl class="user"><dt><b></b></dt><dd>In the following sections, the code below is used for <code>output</code>: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt; <span class="comment">// R is a depth adaptor range</span>
<span class="keywordtype">void</span> output(<span class="keyword">const</span> R&amp; f)
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::range_iterator&lt;R&gt;::type iterator;

    <span class="keywordflow">for</span> (iterator first(boost::begin(f)), last(boost::end(f)); first != last; ++first)
    {
        <span class="keywordflow">for</span> (<span class="keyword">typename</span> iterator::difference_type i(first.depth()); i != 0; --i)
        {
            std::cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
        }
        <span class="keywordflow">if</span> (first.edge() == <a class="code" href="namespaceadobe.html#a99fb83031ce9923c84392b4e92f956b5addca60da0fe2cd03d5bfe3ac54fcebf8">adobe::forest_leading_edge</a>)
        {
            std::cout &lt;&lt; <span class="stringliteral">&quot;&lt;&quot;</span> &lt;&lt; *first &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;
        }
        <span class="keywordflow">else</span>
        {
            std::cout &lt;&lt; <span class="stringliteral">&quot;&lt;/&quot;</span> &lt;&lt; *first &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;
        }
    }
}
</pre></div></dd></dl>
<h3><a class="anchor" id="forest_tutorial_examples_one"></a>
Default Construction and Insert</h3>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classadobe_1_1forest.html" title="A homogeneous hierarchical structure class.">adobe::forest&lt;std::string&gt;</a> forest;
    <span class="keyword">typedef</span> forest::iterator iterator;

    forest f;
    iterator i (f.begin());
    i = <a class="code" href="namespaceadobe.html#a167ae8bc5b0d61aed35b68608bd04e7c">adobe::trailing_of</a>(f.insert(i, <span class="stringliteral">&quot;grandmother&quot;</span>));
    {
        iterator p (<a class="code" href="namespaceadobe.html#a167ae8bc5b0d61aed35b68608bd04e7c">adobe::trailing_of</a>(f.insert(i, <span class="stringliteral">&quot;mother&quot;</span>)));
        f.insert(p, <span class="stringliteral">&quot;me&quot;</span>);
        f.insert(p, <span class="stringliteral">&quot;sister&quot;</span>);
        f.insert(p, <span class="stringliteral">&quot;brother&quot;</span>);
    }
    {
        iterator p (<a class="code" href="namespaceadobe.html#a167ae8bc5b0d61aed35b68608bd04e7c">adobe::trailing_of</a>(f.insert(i, <span class="stringliteral">&quot;aunt&quot;</span>)));
        f.insert(p, <span class="stringliteral">&quot;cousin&quot;</span>);
    }
    f.insert(i, <span class="stringliteral">&quot;uncle&quot;</span>);
    
    output(adobe::depth_range(f));
</pre></div> </dd></dl>
<dl class="user"><dt><b>Results:</b></dt><dd><div class="fragment"><pre class="fragment">
&lt;grandmother&gt;
	&lt;mother&gt;
		&lt;me&gt;
		&lt;/me&gt;
		&lt;sister&gt;
		&lt;/sister&gt;
		&lt;brother&gt;
		&lt;/brother&gt;
	&lt;/mother&gt;
	&lt;aunt&gt;
		&lt;cousin&gt;
		&lt;/cousin&gt;
	&lt;/aunt&gt;
	&lt;uncle&gt;
	&lt;/uncle&gt;
&lt;/grandmother&gt;
</pre></div></dd></dl>
<h3><a class="anchor" id="forest_tutorial_examples_two"></a>
Copy Construction and Reverse</h3>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">    <span class="comment">// This code picks up where the &quot;Default Construction and Insert&quot; example left off.</span>

    forest f2(f);
    iterator f2_grandmother(<a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">adobe::find</a>(adobe::preorder_range(f2), <span class="stringliteral">&quot;grandmother&quot;</span>).base());
    f2.reverse(<a class="code" href="namespaceadobe.html#abf5d15d243fd831313a1dd71f188a1e5">adobe::child_begin</a>(f2_grandmother), <a class="code" href="namespaceadobe.html#ab9adf419db961fb4bc190fefaeb7c40a">adobe::child_end</a>(f2_grandmother));
    
    output(adobe::depth_range(f2));
</pre></div> </dd></dl>
<dl class="user"><dt><b>Results:</b></dt><dd><div class="fragment"><pre class="fragment">
&lt;grandmother&gt;
	&lt;uncle&gt;
	&lt;/uncle&gt;
	&lt;aunt&gt;
		&lt;cousin&gt;
		&lt;/cousin&gt;
	&lt;/aunt&gt;
	&lt;mother&gt;
		&lt;me&gt;
		&lt;/me&gt;
		&lt;sister&gt;
		&lt;/sister&gt;
		&lt;brother&gt;
		&lt;/brother&gt;
	&lt;/mother&gt;
&lt;/grandmother&gt;
</pre></div></dd></dl>
<h3><a class="anchor" id="forest_tutorial_examples_three"></a>
Reverse Iterator</h3>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">    <span class="comment">// This code picks up where the &quot;Default Construction and Insert&quot; example left off.</span>

    output(adobe::depth_range(adobe::reverse_fullorder_range(f)));
</pre></div> </dd></dl>
<dl class="user"><dt><b>Results:</b></dt><dd><div class="fragment"><pre class="fragment">
&lt;grandmother&gt;
	&lt;uncle&gt;
	&lt;/uncle&gt;
	&lt;aunt&gt;
		&lt;cousin&gt;
		&lt;/cousin&gt;
	&lt;/aunt&gt;
	&lt;mother&gt;
		&lt;brother&gt;
		&lt;/brother&gt;
		&lt;sister&gt;
		&lt;/sister&gt;
		&lt;me&gt;
		&lt;/me&gt;
	&lt;/mother&gt;
&lt;/grandmother&gt;
</pre></div></dd></dl>
<h3><a class="anchor" id="forest_tutorial_examples_four"></a>
Node Deletion</h3>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">    <span class="comment">// This code picks up where the &quot;Default Construction and Insert&quot; example left off.</span>

    forest f3(f);
    iterator f3_aunt(<a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">adobe::find</a>(adobe::preorder_range(f3), <span class="stringliteral">&quot;aunt&quot;</span>).base());
    iterator f3_uncle(<a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">adobe::find</a>(adobe::preorder_range(f3), <span class="stringliteral">&quot;uncle&quot;</span>).base());
    f3.erase(<a class="code" href="namespaceadobe.html#a35c224b12c2ddc135f4af991af94df73">adobe::leading_of</a>(f3_aunt), ++(<a class="code" href="namespaceadobe.html#a167ae8bc5b0d61aed35b68608bd04e7c">adobe::trailing_of</a>(f3_uncle)));

    output(adobe::depth_range(f3));
</pre></div> </dd></dl>
<dl class="user"><dt><b>Results:</b></dt><dd><div class="fragment"><pre class="fragment">
&lt;grandmother&gt;
	&lt;mother&gt;
		&lt;me&gt;
		&lt;/me&gt;
		&lt;sister&gt;
		&lt;/sister&gt;
		&lt;brother&gt;
		&lt;/brother&gt;
	&lt;/mother&gt;
&lt;/grandmother&gt;
</pre></div></dd></dl>
<h3><a class="anchor" id="forest_tutorial_examples_five"></a>
Splicing As Siblings to A Node</h3>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">    <span class="comment">// This code picks up where the &quot;Default Construction and Insert&quot; example left off.</span>

    forest f4(f);
    forest f5(f);
    iterator f4_aunt(<a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">adobe::find</a>(adobe::preorder_range(f4), <span class="stringliteral">&quot;aunt&quot;</span>).base());

    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of f4 pre-splice: &quot;</span> &lt;&lt; f4.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of f5 pre-splice: &quot;</span> &lt;&lt; f5.size() &lt;&lt; std::endl;

    <span class="comment">// Note that because f4_aunt is on the leading edge, the spliced forest&#39;s</span>
    <span class="comment">// top nodes will be siblings to f4_aunt.</span>

    f4.splice(f4_aunt, f5);    

    output(adobe::depth_range(f4));

    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of f4 post-splice: &quot;</span> &lt;&lt; f4.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of f5 post-splice: &quot;</span> &lt;&lt; f5.size() &lt;&lt; std::endl;
</pre></div> </dd></dl>
<dl class="user"><dt><b>Results:</b></dt><dd><div class="fragment"><pre class="fragment">
Size of f4 pre-splice: 8
Size of f5 pre-splice: 8
&lt;grandmother&gt;
	&lt;mother&gt;
		&lt;me&gt;
		&lt;/me&gt;
		&lt;sister&gt;
		&lt;/sister&gt;
		&lt;brother&gt;
		&lt;/brother&gt;
	&lt;/mother&gt;
	&lt;grandmother&gt;
		&lt;mother&gt;
			&lt;me&gt;
			&lt;/me&gt;
			&lt;sister&gt;
			&lt;/sister&gt;
			&lt;brother&gt;
			&lt;/brother&gt;
		&lt;/mother&gt;
		&lt;aunt&gt;
			&lt;cousin&gt;
			&lt;/cousin&gt;
		&lt;/aunt&gt;
		&lt;uncle&gt;
		&lt;/uncle&gt;
	&lt;/grandmother&gt;
	&lt;aunt&gt;
		&lt;cousin&gt;
		&lt;/cousin&gt;
	&lt;/aunt&gt;
	&lt;uncle&gt;
	&lt;/uncle&gt;
&lt;/grandmother&gt;
Size of f4 post-splice: 16
Size of f5 post-splice: 0
</pre></div></dd></dl>
<h3><a class="anchor" id="forest_tutorial_examples_six"></a>
Splicing As Children to A Node</h3>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">    <span class="comment">// This code picks up where the &quot;Default Construction and Insert&quot; example left off.</span>

    forest f6(f);
    forest f7(f);
    iterator f6_aunt(<a class="code" href="group__find.html#ga3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">adobe::find</a>(adobe::preorder_range(f6), <span class="stringliteral">&quot;aunt&quot;</span>).base());

    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of f6 pre-splice: &quot;</span> &lt;&lt; f6.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of f7 pre-splice: &quot;</span> &lt;&lt; f7.size() &lt;&lt; std::endl;

    f6_aunt = <a class="code" href="namespaceadobe.html#a167ae8bc5b0d61aed35b68608bd04e7c">adobe::trailing_of</a>(f6_aunt);

    <span class="comment">// Note that because f6_aunt is on the trailing edge, the spliced forest&#39;s</span>
    <span class="comment">// top nodes will be children to f6_aunt.</span>

    f6.splice(f6_aunt, f7);    

    output(adobe::depth_range(f6));

    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of f6 post-splice: &quot;</span> &lt;&lt; f6.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of f7 post-splice: &quot;</span> &lt;&lt; f7.size() &lt;&lt; std::endl;
</pre></div> </dd></dl>
<dl class="user"><dt><b>Results:</b></dt><dd><div class="fragment"><pre class="fragment">
Size of f6 pre-splice: 8
Size of f7 pre-splice: 8
&lt;grandmother&gt;
	&lt;mother&gt;
		&lt;me&gt;
		&lt;/me&gt;
		&lt;sister&gt;
		&lt;/sister&gt;
		&lt;brother&gt;
		&lt;/brother&gt;
	&lt;/mother&gt;
	&lt;aunt&gt;
		&lt;cousin&gt;
		&lt;/cousin&gt;
		&lt;grandmother&gt;
			&lt;mother&gt;
				&lt;me&gt;
				&lt;/me&gt;
				&lt;sister&gt;
				&lt;/sister&gt;
				&lt;brother&gt;
				&lt;/brother&gt;
			&lt;/mother&gt;
			&lt;aunt&gt;
				&lt;cousin&gt;
				&lt;/cousin&gt;
			&lt;/aunt&gt;
			&lt;uncle&gt;
			&lt;/uncle&gt;
		&lt;/grandmother&gt;
	&lt;/aunt&gt;
	&lt;uncle&gt;
	&lt;/uncle&gt;
&lt;/grandmother&gt;
Size of f6 post-splice: 16
Size of f7 post-splice: 0
</pre></div> </dd></dl>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
