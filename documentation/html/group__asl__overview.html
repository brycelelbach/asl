<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: ASL Overview</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="http://sourceforge.net/adobe/">Open @ Adobe</a><br/>
        <a href="http://opensource.adobe.com/">Adobe Open Source</a><br/>
        <a href="http://labs.adobe.com/">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.7.2 -->
<div class="header">
  <div class="headertitle">
<h1>ASL Overview<br/>
<small>
[<a class="el" href="group__asl__home.html">Adobe Source Libraries</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
</table>
<dl class="author"><dt><b>Author:</b></dt><dd>Sean Parent, Adobe Systems Incorporated </dd>
<dd>
Mat Marcus, Adobe Systems Incorporated </dd>
<dd>
Foster Brereton, Adobe Systems Incorporated</dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>December 6, 2004 </dd>
<dd>
April 3, 2007</dd></dl>
<h2><a class="anchor" id="asl_overview_abstract"></a>
Abstract</h2>
<dl class="user"><dt><b></b></dt><dd>This document serves as an overview to the Adobe Source Libraries (ASL). The goal of ASL is to develop the technology necessary to construct commercial applications by assembling generic algorithms through declarative descriptions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The first two significant libraries in ASL are known as the property model library (Adam) and layout library (Eve). They are components for modeling the human interface appearance and behavior in a software application. The property model library and layout library are described along with related libraries. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>ASL is a project within the Adobe Software Technology Lab (STLab); a research group chartered with increasing developer productivity and software quality through better technologies and education. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Adobe Begin is a sample application aimed at implementing the ideas expressed herein. A <a class="el" href="group__widget__reference.html">Widget Reference</a> is available to assist users in the creation of dialogs. There are also many prebuilt dialogs provided from which you can learn by example.</dd></dl>
<h2><a class="anchor" id="asl_overview_toc"></a>
Table of Contents</h2>
<dl class="user"><dt><b></b></dt><dd><ul>
<li><a class="el" href="asl_foreword.html">Personal Foreword</a></li>
</ul>
<ol type="1">
<li><a class="el" href="group__asl__overview.html#asl_overview_intro_to_adam_and_eve">Introduction to the Property Model and Layout Libaries</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_goals_for_adam">Goals for Property Model Library</a><ol type="a">
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_goal_1">Decreasing the Effort Required to Construct an Interface</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_goal_2">Increase the Quality of the Interface Implementation</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_goal_3">Allow Interfaces to be Shared Across Products</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_goal_4">Shifting HI Development to the Designer</a></li>
</ol>
</li>
<li><a class="el" href="group__asl__overview.html#asl_overview_understanding_adam">Understanding The Property Model Library</a><ol type="a">
<li><a class="el" href="group__asl__overview.html#asl_overview_understanding_adam_modelling_controller">Modelling the Controller</a></li>
</ol>
</li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_architecture">Adam &amp; Eve Architecture</a><ol type="a">
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_architecture_overview">Overview</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_expression_language">The Adam Expression Language</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_adam">Adam</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_virtual_machine">Virtual Machine</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_eve2_binding">Binding</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_eve2_guides">Guides</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_eve2_dynamic_evaluation">Dynamic Evaluation</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_adam_and_eve_eve2_outsets_etc">Outsets and Container Geometry</a></li>
</ol>
</li>
<li><a class="el" href="group__asl__overview.html#asl_overview_library_integration">Library Integration</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_open_issues">Appendix - Other Open Issues</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_grammars">Appendix - Grammars</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_future_ideas">Appendix - Future Ideas</a><ol type="a">
<li><a class="el" href="group__asl__overview.html#asl_overview_future_ideas_expresso2">Visual Editor</a></li>
<li><a class="el" href="group__asl__overview.html#asl_overview_future_ideas_eve2">Features Under Consideration For Eve2</a></li>
</ol>
</li>
</ol>
</dd></dl>
<h2><a class="anchor" id="asl_overview_intro_to_adam_and_eve"></a>
Introduction to the Property Model and Layout Libaries</h2>
<dl class="user"><dt><b></b></dt><dd>The property model library consists of a solver and a declarative language for describing constraints and relationships on a collection of values, typically the parameters to an application command (a function). When bound to a human interface (HI), the property model library provides the logic that controls the HI behavior. A property model is similar in concept to a spreadsheet or a forms manager. Values are set and dependent values are recalculated. The property model library provides facilites to resolve interrelated values, but is not a general constraint system.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The layout library consists of a solver and a declarative language for constructing an HI. The layout solver takes into account a rich description of HI elements to achieve a high quality layout rivaling what can be achieved with manual placement. A single HI description suffices for multiple OS platforms and languages. The layout library was developed to work with the property model library but can also be used alone.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>These libraries do not constitute a traditional application framework. They are component libraries which can be incorporated into a number of environments. They can be used together, or independently, but must be combined with other facilities to construct an application. Nearly all of the components which comprise the property model and layout libraries can also be used independently and are documented as part of ASL.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>ASL is being developed in C++, and relies heavily on the Boost libraries &lt;<a href="http://www.boost.org/">http://www.boost.org/</a>&gt; which are required for building ASL.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The layout library was developed with three primary goals and two requirements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Goals:<ol type="1">
<li>Make it easier to specify and modify the layout of a human interface.</li>
<li>Have a single definition of the interface for all platforms.</li>
<li>Have a single definition of the interface for all languages. </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Requirements:<ol type="1">
<li>Must allow piecemeal incorporation into an application.</li>
<li>Generate layouts as good or better than those generated by hand. </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Goal 3 relies on a tokenized string system. ASL provides the xstring library as an example of such a system, but the layout library is not directly dependent on any string system. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example is used throughout this document. It is introduced here to give a feel for what these libraries are and what they do. A simple layout description of a dialog looks like this: <div class="fragment"><pre class="fragment">
layout clipping_path
{
    view dialog(name: "Clipping Path")
    {
        column(child_horizontal: align_fill)
        {
            popup(name: "Path:", bind: @path, items:
            [
                { name: "None", value: empty },
                { name: "Path 1", value: 1 },
                { name: "Path 2", value: 2 }
            ]);
            edit_number(name: "Flatness:", digits: 9, bind: @flatness);
        }
        button(name: "OK", default: true, bind: @result);
    }
}
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Note:</em> For brevity, strings are shown in a simplified form. Normally, a tokenized string system would be used.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="clippingpath.jpg" alt="clippingpath.jpg"/>
<p><strong>Figure 1: The Clipping Path dialog described above in Mac OS X</strong></p></div>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although this example creates a static layout, the layout library can also control the placement of HI elements when elements are hidden or revealed, as a window resizes, or as content changes.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bind</code> attributes in the layout description are what connect the HI elements to an underlying model. In this case the model is a model of the parameters to a function (presumably a function to change the "clipping path" of a document). The property model library manages the constraints and relationships amongst the parameters taking input from HI events, and feeding information back to the widgets for display.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The value of the <code>bind</code> attribute refer to a cell in the property model. The property model for this example is declared as: <div class="fragment"><pre class="fragment">
sheet clipping_path
{
output:
    result                  &lt;== { path: path, flatness: flatness };

interface:
    unlink flatness : 0.0   &lt;== (path == empty) ? 0.0 : flatness;
    path            : 1;
}
</pre></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Binding the numeric text field to the flatness cell in the property model binds the HI display to the value in this cell and also binds the enabled state of the HI to the contributing state of the cell in the model. The text field will toggle between "0.0" and the last user-entered value as the popup is switched between "None" and one of the available paths in the document. When "None" is selected the text field will also be dimmed (in a disabled state) because the flatness cell cannot directly contribute to <code>result</code>; entering a number in the field (and hence setting the flatness cell value) would have no effect on <code>result</code> so the control is disabled.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although changes in the model are reflected in the bound HI, the model does not refer to the HI and is entirely independent. It could be bound to any number of alternate interfaces and the same model is used for script validation. The model is also used for script generation (recording). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although these libraries are being developed to solve problems with application HI development for Adobe products, there are other possible uses of the technology. They could be applied to form layout and logic, web application front-end development, web page layout and logic, or document style sheet layout. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We are also working to extend the concepts in these libraries to apply to the document model within an application.</dd></dl>
<h2><a class="anchor" id="asl_overview_goals_for_adam"></a>
Goals for Property Model Library</h2>
<dl class="user"><dt><b></b></dt><dd>The goals of the property model library are lofty - in part because for this library to be successful it has to be a significantly better way to build the HI component of an application.</dd></dl>
<h3><a class="anchor" id="asl_overview_adam_goal_1"></a>
Decreasing the Effort Required to Construct an Interface</h3>
<dl class="user"><dt><b></b></dt><dd>Ask nearly any software engineer what they hate doing most and the answer will be "building the human interface." Even working on products where the layout library has been adopted, and the engineers are freed from much of the mundane tasks such as getting a button at just the right pixel location; the effort to build the human interface is onerous. In fact, the code associated with the human interface accounts for nearly 1/3 of the code necessary to implement a feature within Adobe applications. Contrast that to the framework code, which accounts for roughly 1/10th of the code in our applications and the potential impact of this project becomes apparent. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The property model library seeks to provide a clear format for modeling what is now managed with complicated event handling code. It also reduces the amount of redundant logic and consolidates common logic for reuse and sharing. The property model library is targeted to replace the current code necessary to implement an interface with description that is a 10:1 reduction in size and complexity and has been shown to achieve as much as a 600:1 reduction.</dd></dl>
<h3><a class="anchor" id="asl_overview_adam_goal_2"></a>
Increase the Quality of the Interface Implementation</h3>
<dl class="user"><dt><b></b></dt><dd>As noted above, there is significant code in Adobe products to manage the HI, and one would expect a proportionate number of bugs. But in reality the number of HI-related bugs is disproportionately high (An explanation for this is detailed below). In sampling one of every 500 bugs in Photoshop's 20,000-bug database, roughly half (in this case it was exactly half) of the bugs fell into the interface layer that the property model targets. These bugs tend to be of lower severity than other bugs but still represent a significant impact on resources. Reviewing bugs across a range of Adobe products revealed that roughly 40% of Adobe products' bugs are "behavioral" in nature. Many of these bugs (4 out of 20 in the Photoshop sampling) simply could not have happened using the property model library. Other bugs, though they may still occur, will be easier to find and fix or will be eliminated altogether by moving more of the implementation closer to the design process.</dd></dl>
<h3><a class="anchor" id="asl_overview_adam_goal_3"></a>
Allow Interfaces to be Shared Across Products</h3>
<dl class="user"><dt><b></b></dt><dd>Adobe's applications have been acquired from other companies and developed internally over more than a decade. Over time, platform requirements have changed and the products have been ported and adapted. The result is that no two major applications are built upon the same application framework. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Increasingly, our applications are expected to share significant HI elements as they are merged into suites and move beyond the role of an isolated domain to a component in a larger workflow. Areas such as file and asset management, text, color, metadata, web optimization, and transparency, are all expected to be both well integrated into each application and common amongst all of them. The layout library has enabled some level of interface layout sharing already. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Integration and code sharing is made difficult because of the disparity between frameworks and object models between applications. Even when the layout is shared, the underlying implementation cannot be shared while still meeting the requirement of being well integrated. The result is that the code comprising the logic behind an HI is replicated for each application using the client application model for widgets and event handling. This is a significant amount of duplicated code and effort. The property model library seeks to consolidate that logic and allow it to be moved and customized easily between our applications regardless of the underlying framework.</dd></dl>
<h3><a class="anchor" id="asl_overview_adam_goal_4"></a>
Shifting HI Development to the Designer</h3>
<dl class="user"><dt><b></b></dt><dd>Currently, a human interface designer is responsible for designing the visuals and may provide some textual description of the behavior. This work is done using graphical tools, such as Photoshop, to draw the interface and annotations are added to describe the behavior. The design is then given to an engineer who "codes" both the layout and the behavior. Sometimes the requested behaviors violate the requirements of the underlying command, forcing the engineer to go back to the designer and resolve the conflicts. It is only after the design is fully implemented by the engineer that significant user testing can take place, usually requiring rework and one or more iterations through the process. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A visual tool built around the layout library would allow the designer to layout the interface in a form that could be used directly by the application developer. Incorporating property model support into such a tool would serve to increase the communication between the development engineer and interface designer by surfacing the constraints and allowing the designer to experiment with correctly functioning interfaces.</dd></dl>
<h2><a class="anchor" id="asl_overview_understanding_adam"></a>
Understanding The Property Model Library</h2>
<dl class="user"><dt><b></b></dt><dd>The design of Adobe's professional applications follow a typical model, view, controller pattern. The model represents the document being edited, and the view is the display of the document within a window. The "controller" is a collection of commands that can be used to modify the document. These commands follow a command pattern (see Gamma, et. al. p. 233) and execute against the document as an undoable transaction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="parameter_flow.jpg" alt="parameter_flow.jpg"/>
<p><strong>Figure 2: The typical flow of command parameters within an application</strong></p></div>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Most of our applications follow this diagram or some variation on the pattern. In this pattern, information from defaults or preferences, or possibly from a script, are combined with state information about the target document. This information, possibly with information provided by the user, is then used to construct the parameters to a command. The command is then executed against the document. If this transaction completes successfully (it may fail if resources are insufficient or the user cancels the operation) then the settings for the command are sent to the scripting system for recording and saved in the preferences. The shaded box is where the command parameters are input by the user and/or validated before handing them off for processing. This is the area where the property model library is focused, with facilities to bind into the rest of the application architecture. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The parameters for a command may be dependent on, or defaulted based on, the state of the document model. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="edit_text_example.jpg" alt="edit_text_example.jpg"/>
<p><strong>Figure 3: The Edit Text Field Depending Upon the State of the Popup</strong></p></div>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The figure above illustrates what happens as part of the command parameter handling process. This is a depiction of the clipping path example used above. Information is fed into the system from a set of defaults (usually what the user selected last) or a script and combined with information from the current document state. This information is fed to the dialog setup code that populates fields and controls within the dialog. (The controls have been formatted either from an appropriate resource description or using the layout library). [****STOPPED HERE****] As the controls in the interface are manipulated, events are generated and other controls are updated in response to reflect validated parameters. Finally, usually in response to the user selecting "OK", the information from the HI fields is gathered, a final validation occurs, the dialog is taken down, and the parameters are sent off for processing. In cases were there is no "cross-talk" between items in the dialog, the behaviors can be coded as simple validating filters attached to each item (for example, a filter on a text edit field that only accepts numbers). More complicated filters can handle simple ranges of values - or combine a couple of HI elements into a standard cluster (like an edit text field bound to a slider). However, even with these simplifications there is duplication of validation code between the scripting validation and that scattered amongst the HI elements. There is custom code required to set-up, teardown, and manage the interaction of the dialog (in very trivial cases the interaction may be managed completely by stock filters). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The command interface is not limited to modal dialogs. Palette interfaces and direct manipulations also construct command parameters. The property model library can be applied in these cases as well. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although this "simple" example does not show it, the interrelationships will quickly exceed the number of items, bounded by <em>(N<sup>2</sup> - N)</em> directional relationships for a fully connected set. A dialog can get prohibitively complicated. For example, the Layer Effects dialog in Photoshop 6 has over 250 elements. Although the interaction between elements is somewhat limited, the resulting complexity is still significant. A dialog such as Image Size only has a handful of items, but is fully interconnected. The resulting pages of logic, despite having been worked on across several releases of Photoshop, are an ongoing source of bugs and bug fixes. Even when implemented with the utmost care, these fixes frequently generate other defects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>All of the code in these event-based systems is tightly bound both to the application framework and to the application document model. This tight coupling prohibits the code from being reused within another application.</dd></dl>
<h3><a class="anchor" id="asl_overview_understanding_adam_modelling_controller"></a>
Modelling the Controller</h3>
<dl class="user"><dt><b></b></dt><dd>In more complicated cases (such as a slider connected to an edit text field) the result is a tangle of circular dependencies. A deeper analysis reveals that the cycles are created because the HI controls are providing two functions - they are both a display and an input. By logically separating these two functions the circular dependencies are broken. Much of the logic that was in the event handlers, script validation, setup, and teardown can now be collapsed into a single "model". What we are left with is a traditional model / view / controller pattern with the HI controls acting as both view and controller. This is depicted in Figure 4. What is being modeled is the parameters to the command that is being constructed. This model is independent of the HI that is bound to it, allowing the designer greater flexibility in changing the layout and the choice of HI elements without impacting the underlying model. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="adam_mvc_design.jpg" alt="adam_mvc_design.jpg"/>
<p><strong>Figure 4: HI Widgets Acting as Both View and Controller Being Split by Adam</strong></p></div>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>This consolidation alone reduces the complexity of the system from <em>(N<sup>2</sup> - N)</em> to simply <em>N</em>. Further, the logic that was replicated between the script validation and the dialog validation can now be shared. Because there is a single model containing the state of the system some of the relationships that had to be coded individually before can now be encapsulated into simple "rules" applied to the system as a whole. For example, any HI designer will tell you that an interface element should be visually disabled if, given the current state of the other interface items, it would have no effect. In a typical event handling system there is no way to determine what will or will not have an effect. With Adam, this rule can be expressed once for the application rather than once for each element that contributes to the enabled state of another. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The Adam modeling system is conceptually similar to a traditional spreadsheet. Cells are named with text identifiers rather than being organized into a row / column layout and grouped into a "sheet". A "sheet" is similar to a C structure, except data members are cells that can have expressions attached which are evaluated when dependent members are modified. The dependency engine is bidirectional, allowing for queries on a given state such as "what input cells effect the output cells." These types of queries are used to drive the enabled state within the controller (if an input cannot affect any output then the controller attached to the input cell is disabled). The reverse dependency lookup is also used for invariant testing, enabling the engine to report what input cells contributed to an invariant violation, not just that one occurred..</dd></dl>
<h2><a class="anchor" id="asl_overview_adam_and_eve_architecture"></a>
Adam &amp; Eve Architecture</h2>
<h3><a class="anchor" id="asl_overview_adam_and_eve_architecture_overview"></a>
Overview</h3>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="adam_and_eve.jpg" alt="adam_and_eve.jpg"/>
<p><strong>Figure 5: The Basic Components of Adam And Eve and How They Interrelate</strong></p></div>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two major components: the parsers and the engines. Eve1 has its own language loosely based on a C syntax. The parser in Eve1 is coupled to the Eve1 engine, making it difficult to provide alternate syntaxes. For Eve2 and Adam the engines are completely decoupled from the language allowing for alternate syntaxes to be developed by providing a parser. Optionally, a formatter can also be provided for direct generation from an Eve2 DOM and Adam sheet. The most obvious choice for an additional syntax is XML, although many other forms have been suggested (direct to HTML, classic Eve, CSS, JavaScript, Java Swing, and platform resources).</dd></dl>
<h3><a class="anchor" id="asl_overview_adam_and_eve_expression_language"></a>
The Adam Expression Language</h3>
<dl class="user"><dt><b></b></dt><dd>The Adam Expression Language (AEL) has been developed as a base expression language for both Adam and Eve2. The syntax borrows heavily from Eve1 and continues in the "C style". An XML based language was considered but rejected because every attempt has led to a language that is verbose and difficult to read. Even with a good visual editor it is expected that text based editing will be the preferred form of editing Adam and Eve descriptions for some users. However, an XML based language as an alternative is not being rejected in general. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The AEL is being designed from the outset to support round-trip editing and good error reporting. The new parser is LL2 and has a simple lexical analyzer. Comments are incorporated into the grammar (not simply consumed as white space by the lexical analyzer) to support round-trip editing with a visual editor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For more information on AEL see the Adam <a class="el" href="group__adam__reference.html">Property Model Language Reference</a>.</dd></dl>
<h3><a class="anchor" id="asl_overview_adam_and_eve_adam"></a>
Adam</h3>
<dl class="user"><dt><b></b></dt><dd>As previously mentioned, an Adam sheet is similar to a C struct. A sheet consists of cell members. Cell members may be of type input, output, interface, logic, constant or invariant. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The example given in the introduction is a sheet specification: <div class="fragment"><pre class="fragment">
sheet clipping_path
{
output:
    result          &lt;== { path: path, flatness: flatness };

interface:
    unlink flatness : 0.0 &lt;== (path == empty) ? 0.0 : flatness;
    path            : 1;
}
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>[Open Issue 1] An invariant is an output cell of type Boolean. A handler can be attached to an invariant that will be called if the invariant evaluates to false. The handler is supplied the name of the invariant, as well as a list of the input cells upon which the invariant is dependent. The default handler throws an exception of type adam::invariant_violation(). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To understand how Adam achieves such expressive power, consider the statement: <div class="fragment"><pre class="fragment">
unlink flatness : 0.0 &lt;== (path == empty) ? 0.0 : flatness;
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As C++ code, this statement would simply mean:<ul>
<li>When executed, evaluate <code>path's</code> output and assign <code>0.0</code> or <code>flatness'</code> input to <code>flatness'</code> output accordingly. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>As an Adam statement the following is implied:<ul>
<li>Whenever <code>path's</code> output is modified, assign either <code>0.0</code> or <code>flatness'</code> input to <code>flatness'</code> output.</li>
<li>If <code>path's</code> output does not equal <code>empty</code>, and <code>flatness'</code> input is modified, then update <code>flatness'</code> output. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Further, the following queries can be made:<ul>
<li>Given a current state, which input cells have an effect upon output cells?</li>
<li>Given a current state, upon which input values is <code>flatness'</code> output dependent?</li>
<li>Which of the values upon which <code>flatness'</code> output is currently dependent was updated most recently? </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>And, finally, actions can be associated with the results of any of the above statements - such as:<ul>
<li>When <code>flatness'</code> output is modified, update the display.</li>
<li>Set the enabled state of the edit text field associated with <code>flatness'</code> input according to whether <code>flatness'</code> input affects any output values, and update it when that state changes. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The more inter-related statements there are in a sheet, the higher the effective expressive power of Adam is relative to a traditional event model. The single statement above replaces a 57 line (15 statements by semicolon count) function in Photoshop. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instance of a sheet is a copy-on-write object in order to support transactional operations. This is useful in implementing undo and it may be used to implement reset and revert to respond to an invariant violation. [Note: copy-on-write could also be used to implement multiple undo within dialogs if we consider this feature useful.] </dd></dl>
<dl class="user"><dt><b></b></dt><dd>[Open issue 2] The input cells on a sheet can be loaded from a dictionary and the output cells can be extracted as a dictionary. This functionality can be used to implement load, save, "favorites", and presets as well as being a useful way to bind a sheet to the application. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Modifying an input cell on a sheet triggers a recalculate (this can be suppressed for setting up a complex state). Any cells dependent on a changed value are recalculated. If an invariant cell returns false on a recalculation an exception is thrown containing the name of the invariant that was violated, as well as any cells (based on the current state of the sheet) that triggered the invariant. [Note, it may also be useful to provide a list of all input cells upon which the invariant is dependent. A notion of a "weak invariant" may also be useful that would halt propagation and cause any further dependent output cells to go to an "invalid" state. This will require further experience to see what is needed.] </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Logic cells are used for intermediate calculations and their state can neither be read nor set from outside the sheet. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Interface cells are used for both input and output. Normally an interface cell's input and output values stay in sync with one another. It is possible to prefix an interface cell with the "unlink" keyword, preventing back propagation of the output value to the input value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>[Open Issue 3] [Open Issue 4] Sometimes an interface is dependent upon the notion of what happened most recently. For example - an edit text field displaying "width" in a resize dialog might either display what the user typed into width or what was calculated when the user changed height. To support this notion, Adam maintains a generation count on the sheet that is incremented with each recalculation. Cells are stamped with the generation count when they are modified as the result of a recalculation.</dd></dl>
<h3><a class="anchor" id="asl_overview_adam_and_eve_virtual_machine"></a>
Virtual Machine</h3>
<dl class="user"><dt><b></b></dt><dd>The Virtual Machine is a simple stack machine for evaluating expressions. An expression is reduced to a code sequence where each code represents either a value or an operand. Values are pushed, and operands are applied to values on the top of the stack, pushing the result. An infix expression can be reconstructed from the sequence by overriding the operators. This is useful for roundtrip editing. Conceptually AVM is very similar to FORTH or the PostScript language and supports pushing a code sequence as a value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In Adam, dependencies are tracked by monitoring cell lookups during execution of statements. Lookup is deferred until actual execution. The short-circuit Booleans and conditional operator take expressions as parameters, so which cells are marked as being dependent on a given expression is dependent on the current state of the sheet. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>[Open Issue 5] it may be desirable to delay evaluation of parameters to functions until the function requests evaluation. Although that would complicate scoping rules, it would allow function to be written that conditionally used their parameters and hence would do a better job at tracking dependencies.</dd></dl>
<h4><a class="anchor" id="asl_overview_adam_and_eve_eve2_binding"></a>
Binding</h4>
<dl class="user"><dt><b></b></dt><dd>A key feature of Eve2 is the ability to bind an HI element to a cell in an Adam sheet. Binding is done through various bind attributes. The value of a bind attribute is the name of an Adam cell or cells. For example: <div class="fragment"><pre class="fragment">
check_box(name: "Check this", bind: @check_this);
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A name can also be used to bind other attributes to a sheet. For example, if the name of the above check box is something set by the user, this may appear as: <div class="fragment"><pre class="fragment">
check_box(name: @user_name, bind: @check_this);
</pre></div></dd></dl>
<h4><a class="anchor" id="asl_overview_adam_and_eve_eve2_guides"></a>
Guides</h4>
<dl class="user"><dt><b></b></dt><dd>Guides are a generalization of what the label_width and top_inset attributes were in Eve1. In Eve2 guides will be able to handle cross hierarchy connections to allow <em>n</em>-column alignment and baseline alignment. For the most part, guides will behave automatically - invisible to the user (set by the client code and solved by the engine). [Note: There currently exists a good algorithm for finding guide correspondence. The algorithm for solving the positions is problematic but should be sufficient to do "more than Eve1" in the initial implementation.]</dd></dl>
<h4><a class="anchor" id="asl_overview_adam_and_eve_eve2_dynamic_evaluation"></a>
Dynamic Evaluation</h4>
<dl class="user"><dt><b></b></dt><dd>Resizing a view, either directly because of a user dragging out the size or in response to a change in content or state, is directly analogous to laying out the contents of a view with some additional constraints (such as the minimum size of the enclosing view). After Eve1 was developed the realization came that it could also be used to control the resize logic. The only problem was that the Eve engine was tangled with the parser and so could not adjust a layout after a programmatic change. Eve2 untangles this dependency and provides an API for adjusting attributes and forcing a recalculate of the layout.</dd></dl>
<h4><a class="anchor" id="asl_overview_adam_and_eve_eve2_outsets_etc"></a>
Outsets and Container Geometry</h4>
<dl class="user"><dt><b></b></dt><dd>In Eve1 outsets are intended to ensure space is available for drop shadows, default highlights, OS control "slop", and the like. Some effort is made to adjust the size and location of items based on the outsets, however, this logic is currently flawed, and can lead to both improper outsets as well as improper placement and sizing of items. Correcting this flaw, especially with the addition of guides, would add considerable complexity to the engine. However, when used properly, outsets should not affect the location or size of an item and doing so leads to a visual defect in the appearance of the dialog. Rather, outsets are intended to be "absorbed" by white-space (such as a margin or space between items). Eve2 will apply the outsets correctly in a post-pass after layout. If a size or location adjustment is necessary a diagnostic will be output, but the layout will not be altered. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Eve1 also has no notion of the visual geometry of the frame of a container; rather margins on the frame are adjusted to include the frame. Eve2 adds the notion of a frame and an inset (a different notion than the poorly named inset in Eve1 which should have been named indent). This make it easier for the client code to specify the geometry of a container (the code can set a fixed frame width instead of continually adding the frame to the margin) and allow for better detection of improper overlap in the post-pass.</dd></dl>
<h2><a class="anchor" id="asl_overview_library_integration"></a>
Library Integration</h2>
<dl class="user"><dt><b></b></dt><dd>The integration of ASL into client code is fairly straightforward. Because ASL does not rely on inheritance for integration into client code, the integration process is more about adding support code than converting code already present. Figure 6 outlines a possible integration of ASL into client code. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div align="center">
<img src="codebase.jpg" alt="codebase.jpg"/>
<p><strong>Figure 6: ASL Code Integration and Client Support Code</strong></p></div>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are clear boundaries between ASL code, client code, and the support code required to bind ASL to the client. Processes shaded in red represent code required of the client. Processes shaded in blue are provided by the ASL. OS routines are shaded in green. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The process begins with Adam and Eve definitions describing an interface (a dialog, for example). The client supplies code to read in these definitions and relay them to the respective parsers for Adam and Eve. The parsers should interact with another suite of support code out the other side, which will relay pertinent information to Adam and Eve. Note too that the parser-to-engine support code might interact with widget set support code in initializing controls, windows, and the like. Adam and Eve will execute over the data provided to them, and communicate results to widget set support code. This code will convert data and parameters from the two engines into information useable by the OS. The application relating to the OS should be done at the client support code level. When the OS calls back to the client with events and data, the client support code should relay pertinent information back to Adam and Eve. Adam and Eve will update necessary parameters and send the notifications to the client support code, which relays important information back to the OS (a new wiget value, for example). This cycle of OS/Client/ASL/Client/OS will continue as the user interacts with the interface, and is the "event loop" model with Adam and Eve integrated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Most of the client integration code is fairly simple. The most complex piece of code is the widget support set as callbacks from Adam, Eve, their respective parsers, and the OS come together. Even then, the widget set support code is complex in terms of size, not algorithmic complexity. The code for a given routine is often just a matter of filtering and translating data, then routing that data to the appropriate destination. The most complicated processes in client code should lie outside this model. After all, this code is the means by which parameters are constructed for processes; the process itself should be independent of this code.</dd></dl>
<h2><a class="anchor" id="asl_overview_open_issues"></a>
Appendix - Other Open Issues</h2>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>Currently Adam is loosely typed. It may be desirable to be able to declare a type for a cell and have the type enforced. If this is done, then a qualifier "optional" will be added to denote that the field could also contain "empty".</li>
<li>Investigating XForms. Structured sheets and sheet inclusion.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="asl_overview_grammars"></a>
Appendix - Grammars</h2>
<dl class="user"><dt><b></b></dt><dd>The grammars in this document are expressed using EBNF (Extended Backus-Naur Form) notation. EBNF is defined in the ISO-14977 standard. Available from the <a href="http://webstore.ansi.org/ansidocstore/product.asp?sku=ISO%2FIEC+14977%3A1996">ANSI web site in PDF</a> for a cost of $38.00. The final draft of the document is also <a href="http://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf">available for free online</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are currently four grammars. They can be found in the following files:<ul>
<li><a class="el" href="group__adam__reference.html">Property Model Language Reference</a></li>
<li><a class="el" href="group__eve__reference.html">Layout Library Language Reference</a></li>
<li><a class="el" href="group__expression__reference.html">Expression Reference</a> (describes the lexical grammar and the expression grammar)</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="asl_overview_future_ideas"></a>
Appendix - Future Ideas</h2>
<h3><a class="anchor" id="asl_overview_future_ideas_expresso2"></a>
Visual Editor</h3>
<dl class="user"><dt><b></b></dt><dd>A visual editor for layout and property model libraries would be a great addition to ASL (the Begin example application is evolving in this direction). Eventually it will have a double editor view (outline and preview) but the preview window will also support direct manipulation. A source view (ala GoLive) may also be provided. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Some support will be provided to simplify the process of cross platform previewing. The incorporation of the property model library will allow for active simulations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A tokenized string system can be successful in isolating what needs to be localized within an application. However, a major problem that still remains to be solved is determining the context of a string for the appropriate translation. It is a goal to be able to provide this context information in an editor in the form of a "find string..." command. This will be able to pull up the appropriate HI where the string appears. In the case of validation messages, the HI can be displayed in context with the property model rule that will trigger the message.</dd></dl>
<h3><a class="anchor" id="asl_overview_future_ideas_eve2"></a>
Features Under Consideration For Eve2</h3>
<dl class="user"><dt><b></b></dt><dd>An API for directly manipulating the Eve hierarchy could be useful for very dynamic views. Being able to bind a value to a node in a view allows for some simple direct setting of values - but not for structure manipulation. An XPath interface onto the Eve hierarchy could be a useful future addition. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A maximum size constraint for a layout would be very useful for palettes. Currently you can set a minimal size that is of some use but requires hand inspection and adjustments for localization. A minimal solution would allow for an alternate view definition if a size constraint were violated. Another option would be to gracefully degrade the layout (breaking guide links, and formatting options) to force a dialog to fit. A combination of these two would most likely eliminate significant localization effort. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A previous experimental version of Eve could adjust a layout for word wrapped text. This was fairly straightforward to implement and will most likely make it into a release of Eve2. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The ability to directly specify menu items was not possible in Eve1 because the dataset was not rich enough and custom container layout was not allowed. In Eve2 there are several ways a client could support this feature. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Adobe applications are currently moving to allow for custom key bindings at the application level. If this feature were to be extended into dialogs it may be desirable to have a feature in Eve or in a tokenized string system to support this. At this time however, there are no suggestions as to how such a feature would be implemented. </dd></dl>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
