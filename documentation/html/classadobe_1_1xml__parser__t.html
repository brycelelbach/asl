<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: xml_parser_t&lt; O &gt; Class Template Reference</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="http://sourceforge.net/adobe/">Open @ Adobe</a><br/>
        <a href="http://opensource.adobe.com/">Adobe Open Source</a><br/>
        <a href="http://labs.adobe.com/">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.7.2 -->
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceadobe.html">adobe</a>      </li>
      <li><a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>      </li>
    </ul>
  </div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>xml_parser_t&lt; O &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__asl__xml__parser.html">XML Parser (and supporting constructs)</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="adobe::xml_parser_t" --><!-- doxytag: inherits="boost::noncopyable" -->
<p>A relatively lightweight and simple xml (subset) parser.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="xml__parser_8hpp_source.html">adobe/xml_parser.hpp</a>&gt;</code></p>

<p><a href="classadobe_1_1xml__parser__t-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__asl__xstring.html#ga3cba22a3d7415214dfdfee7b2d3d5f2f">xml_element_proc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#af3687fd97ef68e193747371a37679100">callback_proc_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; bool(const <br class="typebreak"/>
<a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef xml_lex_t::token_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a06ef4f00c3f9746458bc8d84dafa2d9e">token_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structadobe_1_1line__position__t.html">line_position_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a88fa51c35dd13a7c4845fbbf2c0243b2">next_position</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#adb7b7cbfd11211cd642b67cc646968bc">operator=</a> (const <a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a08fb1267061b939749eb6a801949fed3">parse_content</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a98c8def6deb836dad9a5e7a7da340a9c">parse_document</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a8a60f66f94c6d678bc403ef8785ccf2e">parse_element_sequence</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#ae4c20e9594632892ecd3e35b7368a4a7">set_preorder_predicate</a> (<a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a> pred)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#ab2ccb6d7cf2d0dad6fbb6519ce99d6a3">xml_parser_t</a> (const <a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#ae609963b384cd8b4866118c240284e76">xml_parser_t</a> (<a class="el" href="namespaceadobe.html#a3e248dbe068eed9a0b0cae49818e935a">uchar_ptr_t</a> first, <a class="el" href="namespaceadobe.html#a3e248dbe068eed9a0b0cae49818e935a">uchar_ptr_t</a> last, const <a class="el" href="structadobe_1_1line__position__t.html">line_position_t</a> &amp;position, <a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a> predicate, <a class="el" href="classadobe_1_1xml__parser__t.html#af3687fd97ef68e193747371a37679100">callback_proc_t</a> callback, O output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a8b6fc2a745d0ac3e55979ae19fcfd03b">~xml_parser_t</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a7ea3234a5321799caddc563d09673ca3">content_callback</a> (<a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;result_element, const <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;old_element, const <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;start_tag, const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> attribute_set, const <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;content, bool preorder_parent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classadobe_1_1xml__parser__t.html#a06ef4f00c3f9746458bc8d84dafa2d9e">token_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a516db249450812f76e274e9ba8f2b998">get_token</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#ab9f948a5329c85aa7861a90c05583fd4">is_attribute</a> (<a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;name, <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#ac56ad6e038e9eb8b568716665151f718">is_attribute_set</a> (<a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;attribute_set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a82346a4fbf835f6927443820de3780d7">is_bom</a> (<a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;bom)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a5307e252a6daacf7e0a82b93bd5d0a07">is_content</a> (<a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;<a class="el" href="structadobe_1_1element.html">element</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#aee8b370eb2b72e3e5ee03ad5786e9142">is_e_tag</a> (<a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;name, <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;close_tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a9cce5ff4ee09280d67a50dcb6d9b22a1">is_element</a> (<a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;<a class="el" href="structadobe_1_1element.html">element</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#abff29ba11ce089101b78d16455547d46">is_prolog</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#afb9bdc1714f2815fbca99a63c40cff27">is_token</a> (xml_lex_token_set_t name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a4ed5db8e91ae9976c65716f7f7d71edf">is_token</a> (xml_lex_token_set_t name, <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#ac5c6570aa6ed80e4d7c228af88829c42">is_xml_decl</a> (<a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;xml_decl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a968822d98a344ef6aeb0bbcd36c1a66f">putback</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#aa5ce0a477296b065be7f3e0b3ddc6d05">require_token</a> (xml_lex_token_set_t name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#aa961c015d3eab65d0c27dc010b5e5ef2">require_token</a> (xml_lex_token_set_t name, <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#abe0c1f897ab0fa4d49f228af8d32fbd9">throw_exception</a> (const char *error_string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a3e5f6ac60026994518b28d0226e7666e">throw_exception</a> (xml_lex_token_set_t found, xml_lex_token_set_t expected)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classadobe_1_1xml__parser__t.html#af3687fd97ef68e193747371a37679100">callback_proc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#ab8baf66bcc875d9acc8a28f2665a79d2">callback_m</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">O&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#a85d84ef7746b33dd4e0fe2edcb07506f">output_m</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#aee18efd3107beea00b9faea41e55ff3b">pred_m</a></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&lt; O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classadobe_1_1xml__parser__t.html#aeed931c491ff72010b3e25cc444d0027">make_xml_parser</a> (<a class="el" href="namespaceadobe.html#a3e248dbe068eed9a0b0cae49818e935a">uchar_ptr_t</a> first, <a class="el" href="namespaceadobe.html#a3e248dbe068eed9a0b0cae49818e935a">uchar_ptr_t</a> last, const <a class="el" href="structadobe_1_1line__position__t.html">line_position_t</a> &amp;position, typename <a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&lt; O &gt;::<a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a> predicate, typename <a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&lt; O &gt;::<a class="el" href="classadobe_1_1xml__parser__t.html#af3687fd97ef68e193747371a37679100">callback_proc_t</a> callback, O output)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename O&gt;<br/>
 class adobe::xml_parser_t&lt; O &gt;</h3>

<dl class="user"><dt><b>Introduction</b></dt><dd>For an interesting number of xml applications, even the most simple conforming xml parsers are overkill. This is not a criticism of such parsers. Indeed, most such systems, expat &lt;<a href="http://expat.sourceforge.net">http://expat.sourceforge.net</a>&gt; for example, are excellent solutions for processing xml documents from generic or unknown sources. However, there exist a number of applications that apply strict preconditions to the xml documents they process and/or tightly control the source of their documents. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Examples of such applications include preference files (which are typically read and written by a program and not intended to be generically edited) and program configuration files (e.g. localization glossaries). These examples and the applications they represent have a number of characteristics in common: <ul>
<li>The xml file is not intended to be generically editable or processed by other xml tools. </li>
<li>The application does not require a validating parser. </li>
<li>The application can require that documents are encoded with a specific character encoding (e.g. it can require utf8-encoding). </li>
<li>The application does not use "advanced" capabilities of xml documents.</li>
</ul>
For applications such as these, <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> delivers a simple and efficient solution. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> enforces well-formedness and provides a sax-like interface to the application. Although <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> implements much of the XML 1.1 specification &lt;<a href="http://www.w3.org/TR/xml11">http://www.w3.org/TR/xml11</a>&gt;, it is not strictly a conforming parser because of these deviations: <ul>
<li>Validation schemes (e.g. DTDs, XML Schemas) are not supported. </li>
<li>Documents must be encoded in an 8-bit character encoding for which US-ASCII is a proper subset (e.g. US-ASCII, UTF-8, ISO-Latin-1). </li>
<li>The parser accepts UTF-8 and UTF-16 BOMs at the start of a document stream but will throw an exception if a UTF-16 BOM is encountered. </li>
<li>Namespaces are not supported. </li>
<li>The parser recognizes processing instructions but ignores them, neither handling processing instructions nor passing them to the application. </li>
<li>The parser recognizes comments but ignores them, neither handling comments nor passing them to the application. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, an application can use <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> to parse some document fragments that may not be conforming xml documents in their own right. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>All strings <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> passes to the application are in the form of adobe::token_range_t, which are essentially const character ranges. These ranges refer to ranges within the xml data being parsed. This is a large part of how <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> delivers speed and memory efficiency, by eliminating data copying in the parser. The application is free to copy any data it requires. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For ease of use, applications are encouraged to use a helper function, adobe::make_xml_parser, to create <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> objects. Because <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> is a template class, templatized on the type of its output iterator, correctly speaking the concrete name of a parser can be confusing or overly wordy. For most applications, the using make_xml_parser is significantly easier. As in: <div class="fragment"><pre class="fragment">
adobe::make_xml_parser(start_of_xml_document,
                       end_of_xml_document,
                       line_position_t("sample document"),
                       my_preorder_predicate,
                       my_content_callback,
                       my_output_iterator).parse_document();</pre></div> Note that in this usage, the parser is never even stored in a local variable. Instead, the result of make_xml_parser is immediately told to parse the document. This is a very common coding pattern for creating and using <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a>. </dd></dl>
<dl class="user"><dt><b>Basic Parsing Model</b></dt><dd><a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> uses two application callbacks and one app-provided object, an OutputIterator, to process xml data. One app callback is called the content callback and allows the application to process the data of and in a single element. The second callback, called the preorder predicate, allows the application to inform the parser that a given element needs to be processed by the app's content callback, as opposed to being processed by the parser itself. In the following discussion, we will refer to this sample xml document: <div class="fragment"><pre class="fragment">
&lt;parent id="node1"&gt;
	&lt;simple-child id="node2"/&gt;
	&lt;complex-child id="node3"&gt;
		&lt;grandchild id="node4"/&gt;
	&lt;/complex-child&gt;
&lt;/parent&gt;</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> identifies the range corresponding to a given element and its contents -- in the example document above, the first element encountered is the parent element, which encompasses the enter document. The app's preorder predictate is called with the name of the element, "parent" in the example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the preorder predicate returns true for a given element, then the app's content callback is invoked, passing the name of the element, its attributes (collected into an <a class="el" href="structadobe_1_1attribute__set__t.html" title="An associated array based on adobe::token_range_t. A utility class for the xml_parser_t.">adobe::attribute_set_t</a>), and its contents. Continuing our example, the content callback would be given the name "parent", an attribute set corresponding to { ("id","node1") }, and a content range that began after the closing '&gt;' character in the start tag and ending at the '&lt;' character in the "&lt;/parent&gt;" tag. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the preorder predicate returns false for a given element, <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> copies the element's tag to the output iterator if the tag is an empty tag (i.e. one closed with the "/&gt;" sequence, as in &lt;empty-tag/&gt;). When the element contains content, <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> recursively creates a parser to process the contents of the element, reusing its same preorder predicate, content callback, and output iterator for the new parser. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When it is invoked, the application's content callback is responsible for processing the content of the indicated element and returning the token_range_t that should be copied to the output iterator. This range can be empty if nothing should be copied to the output iterator. Alternatively, the callback can return the original content range or a completely altered range, as appropriate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>From this basic parsing model, a wide variety of simple xml applications can be written, although the combinatorics of applying the three concepts from which the parser is built can be daunting. Luckily, just about all parsers fall into one of two categories for which we can describe a basic usage pattern that makes the job significantly easier. Those two categories are Document Filters and Command Processors. </dd></dl>
<dl class="user"><dt><b>Building Document Filters</b></dt><dd>A document filter is fundamentally an application that consumes a stream of characters containing markup and produces a stream of characters derived from that input stream. Such an application could be as complex as an XST Transform implementation or as simple as a string localization application. In fact, adobe::xstring is a good example of a document filter that uses <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Document filters use the parser's output iterator as the location to which the output (or processed) data is written. As such, it is common to use std::ostream_iterator or std::back_inserter(my_string) as the output iterator when creating parsers for filter applications. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A filter's preorder predicate returns true for any element that the filter wishes to change in the output stream. The filter's content callback examines the content of each such element and provides replacement text to be output. For example, consider a simple example whereby an attribute of some tags are used as keys to look up replacement text. Such a simple application could be written like so: <div class="fragment"><pre class="fragment">
static const token_range_t target_tag_k( static_token_range("replace-me") );

token_range_t lookup_replacement_text(const token_range_t&amp;);

bool my_preorder_predicate(const token_range_t&amp; tag_name)
{
	return token_range_equal(tag_name, target_tag_k);
}

token_range_t my_content_callback(
	const token_range_t&amp;     /* entire_element_range */,
	const token_range_t&amp;     /* name */,
	const attribute_set_t&amp;   attribute_set,
	const token_range_t&amp;     value)
{
	static const token_range_t id_attr_k(  static_token_range("id") );

	const token_range_t id( attribute_set[id_addr_k] );
	if (0 == boost::size(id))
		throw std::runtime_error("replace-me tags require an id attribute");

	return lookup_replacement_text(id);
}</pre></div> With this application (and appropriate pre-population of a replacement dictionary), xml input data like this <div class="fragment"><pre class="fragment">
Dear &lt;replace-me id="their-name"/&gt;,
Thank you for your recent letter of &lt;replace-me id="date"/&gt;. Yadda Yadda Yadda.
Sincerely,
&lt;replace-me id="my-name"/&gt;</pre></div> might come out looking like this <div class="fragment"><pre class="fragment">
Dear Mr. Smith,
Thank you for your recent letter of 17 June. Yadda Yadda Yadda.
Sincerely,
John Q. Public</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An application like that described above might be initiated with a function written like this: <div class="fragment"><pre class="fragment">
std::string perform_markup_replacement(const std::string&amp; input)
{
	std::string result;
	
	make_xml_parser(
			input.begin(), input.end(),
			line_position_t("markup replacement string"),
			my_preorder_predicate,
			my_content_callback,
			std::back_inserter(result)).parse_content();

	return result;
}</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that we use std::back_inserter(result) for the output iterator to which the processed output is written. This has the effect of storing the result in a new string to be returned from the function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note also that the function calls the parser's parse_content member function. This is because our source code is not an xml document. Specifically, it is not well-formed (e.g. missing a root element). However, the data is valid xml content (i.e. if one wrapped it with a start and end tag, the result could be a well-formed document. Thus, the data can be processed via parse_content. </dd></dl>
<dl class="user"><dt><b>Building Command Processors</b></dt><dd>A command processor is a more generic model of an xml application than a document filter in which the application performs some action in response to each element in a document. The net result is often the creation or annotation of some program structure (e.g. modifying application preferences) or performing some structured program function (e.g. drawing graphics). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>By their nature, command processors are often unconcerned with the output iterator associated with the parser object. Similarly, command processors typcially perform some action with each tag in the document. As it happens, helpers exist to trivialize each function: <a class="el" href="structadobe_1_1always__true.html">adobe::always_true</a> and adobe::implementation::null_output_t. [The author concedes that clients are encouraged to avoid direct use of things in the adobe::implementation namespace, but null_output_t is just too damned useful to avoid in this case.] Using these helpers, command processors can trivially ignore both the output iterator and preorder predicate and can concentrate on the content callback, where all the action of a command process typically takes place. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Consider a simple document that describes a piece of graphics: <div class="fragment"><pre class="fragment">
&lt;canvas&gt;
	&lt;rect sides="0 0 100 100"/&gt;
	&lt;circle center="5 5" radius="10"/&gt;
	&lt;polygon vertices="1 2 6 8 1 8"/&gt;
&lt;/canvas&gt;</pre></div> Assuming that the parser's preorder predicate can be convinced to return true for all tags in the document (we'll do this later), this document can be parsed with a simple content callback. <div class="fragment"><pre class="fragment">
token_range_t my_content_callback(
	const token_range_t&amp;     /* entire_element_range */,
	const token_range_t&amp;     name,
	const attribute_set_t&amp;   attribute_set,
	const token_range_t&amp;     value,
	graphic_context_t&amp;		 graphics)
{
	static const token_range_t canvas_tag_k(  static_token_range("canvas") );
	static const token_range_t rect_tag_k(  static_token_range("rect") );
	static const token_range_t circle_tag_k(  static_token_range("circle") );
	static const token_range_t polygon_tag_k(  static_token_range("polygon") );

	if (token_range_equal(canvas_tag_k, name))
	{
		make_xml_document(value.first, value.second,
			line_position_t("canvas"),
			adobe::always_true&lt;token_range_t&gt;(),
			boost::bind(my_simple_content_callback, _1, _2, _3, _4, boost::ref(graphics)),
			adobe::null_output_t()).parse_content();
	}
	else if (token_range_equal(rect_tag_k, name))
	{
		if (0 != boost::size(value))
			throw std::runtime_error("rect elements must be empty");
			
		draw_rectangle(attribute_set, graphics);
	}
	else if (token_range_equal(circle_tag_k, name))
	{
		if (0 != boost::size(value))
			throw std::runtime_error("circle elements must be empty");

		draw_circle(attribute_set, graphics);
	}
	else if (token_range_equal(polygon_tag_k, name))
	{
		if (0 != boost::size(value))
			throw std::runtime_error("polygon elements must be empty");

		draw_polygon(attribute_set, graphics);
	}
	else
	{
		throw std::runtime_error("encountered unrecognized tag");
	}

	return token_range_t();
}

void draw_graphics(const std::string&amp; xml_shape, graphics_context_t&amp; graphics)
{
	make_xml_document(xml_shape.begin(), xml_shape.end(),
		line_position_t("xml shape"),
		adobe::always_true&lt;token_range_t&gt;(),
		boost::bind(my_content_callback, _1, _2, _3, _4, boost::ref(graphics)),
		adobe::null_output_t()).parse_document();
}</pre></div> With this content callback function and external entry function, we have implemented a simple system that draws graphics based on the contents of an xml document and provides a modicum of error checking on the document contents (e.g. tags that are not allowed to have complex content confirm this fact). One potential problem is that this application does not guarantee that the root element is a canvas. Indeed, a document with a single &lt;rect ... /&gt; element is conformant with the application, as written above. This may either be good or bad, depending on the design of your specific application. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although the implementation above is rather simple and straightforward, command processors are often more complex. Documents processed by command processors often contain sub-structures that must themselves be parsed. Consider this, slightly more complex, version of our example graphics document: <div class="fragment"><pre class="fragment">
&lt;canvas&gt;
	&lt;rect sides="0 0 100 100"/&gt;
	&lt;circle center="5 5" radius="10"/&gt;
	&lt;group translation="5 10"&gt;
		&lt;polygon&gt;
			&lt;vertex xy="1 2"/&gt;
			&lt;vertex xy="6 8"/&gt;
			&lt;vertex xy="1 8"/&gt;
		&lt;/polygon&gt;
		&lt;rect sides="3 3 10 10"/&gt;
	&lt;/group&gt;
&lt;/canvas&gt;</pre></div> Here, the polygon element's vertices are elements within the polygon's content instead of attributes. This requires polygon's content to be parsed to create an appropriate primitive to draw. Similarly, the document grammar has added a group element that groups primitives together within a coordinate transformation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As it happens, these complications do not significantly complicate our code. Rather, it encourages us to refactor the code into sets of composable functions. As we modify our system to accomodate these changes, we will add a correctness check that the root element is what we expect. <div class="fragment"><pre class="fragment">
token_range_t my_polygon_callback(
	const token_range_t&amp;     /* entire_element_range */,
	const token_range_t&amp;     name,
	const attribute_set_t&amp;   attribute_set,
	const token_range_t&amp;     /* value */,
	polygon_t&amp;				 polygon)
{
	static const token_range_t vertex_tag_k(  static_token_range("vertex") );

	if (token_range_equal(vertex_tag_k, name))
	{
		polygon.add_vertex( make_vertex(attribute_set) );
	}
	else
	{
		throw std::runtime_error("encountered expected tag inside polygon content");
	}

	return token_range_t();
}

token_range_t my_group_callback(
	const token_range_t&amp;     /* entire_element_range */,
	const token_range_t&amp;     name,
	const attribute_set_t&amp;   attribute_set,
	const token_range_t&amp;     value,
	graphic_context_t&amp;		 graphics)
{
	static const token_range_t rect_tag_k(  static_token_range("rect") );
	static const token_range_t circle_tag_k(  static_token_range("circle") );
	static const token_range_t group_tag_k(  static_token_range("group") );
	static const token_range_t polygon_tag_k(  static_token_range("polygon") );

	if (token_range_equal(group_tag_k, name))
	{
		graphic_context_t translated_graphics( graphics, attribute_set );

		make_xml_document(value.first, value.second,
			line_position_t("group"),
			adobe::always_true&lt;token_range_t&gt;(),
			boost::bind(my_group_callback, _1, _2, _3, _4, boost::ref(translated_graphics)),
			adobe::null_output_t()).parse_content();
	}
	else if (token_range_equal(rect_tag_k, name))
	{
		if (0 != boost::size(value))
			throw std::runtime_error("rect elements must be empty");
			
		draw_rectangle(attribute_set, graphics);
	}
	else if (token_range_equal(circle_tag_k, name))
	{
		if (0 != boost::size(value))
			throw std::runtime_error("circle elements must be empty");

		draw_circle(attribute_set, graphics);
	}
	else if (token_range_equal(polygon_tag_k, name))
	{
		polygon_t polygon;

		make_xml_document(value.first, value.second,
			line_position_t("polygon"),
			adobe::always_true&lt;token_range_t&gt;(),
			boost::bind(my_polygon_callback, _1, _2, _3, _4, boost::ref(polygon)),
			adobe::null_output_t()).parse_content();

		draw_polygon(polygon, graphics);
	}
	else
	{
		throw std::runtime_error("encountered unrecognized tag in group");
	}

	return token_range_t();
}

token_range_t my_canvas_callback(
	const token_range_t&amp;     /* entire_element_range */,
	const token_range_t&amp;     name,
	const attribute_set_t&amp;   attribute_set,
	const token_range_t&amp;     value,
	graphic_context_t&amp;		 graphics)
{
	static const token_range_t canvas_tag_k(  static_token_range("canvas") );

	if (token_range_equal(canvas_tag_k, name))
	{
		make_xml_document(value.first, value.second,
			line_position_t("canvas"),
			adobe::always_true&lt;token_range_t&gt;(),
			boost::bind(my_group_callback, _1, _2, _3, _4, boost::ref(graphics)),
			adobe::null_output_t()).parse_content();
	}
	else
	{
		throw std::runtime_error("encountered unrecognized tag in document");
	}

	return token_range_t();
}

void draw_graphics(const std::string&amp; xml_shape, graphics_context_t&amp; graphics)
{
	make_xml_document(xml_shape.begin(), xml_shape.end(),
		line_position_t("xml shape"),
		adobe::always_true&lt;token_range_t&gt;(),
		boost::bind(my_canvas_callback, _1, _2, _3, _4, boost::ref(graphics)),
		adobe::null_output_t()).parse_document();
}</pre></div> Note that this solution guarantees that the root element is a canvas, accomodates groups that contain graphic primitives and other groups, and parses elements within polygon content as vertices. An interesting side effect of the refactoring that produced this system is that the functions tend to be smaller and more composable than the single monolithic function in our first example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>And because <a class="el" href="classadobe_1_1xml__parser__t.html" title="A relatively lightweight and simple xml (subset) parser.">xml_parser_t</a> is an exceptionally lightweight object, the overhead of creating sub-parsers for each specific piece of content is trivial for all but the most stack-restricted programs. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00442">442</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="af3687fd97ef68e193747371a37679100"></a><!-- doxytag: member="adobe::xml_parser_t::callback_proc_t" ref="af3687fd97ef68e193747371a37679100" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__asl__xstring.html#ga3cba22a3d7415214dfdfee7b2d3d5f2f">xml_element_proc_t</a> <a class="el" href="classadobe_1_1xml__parser__t.html#af3687fd97ef68e193747371a37679100">callback_proc_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00445">445</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af45b9d777cf02f50249b15f34999e444"></a><!-- doxytag: member="adobe::xml_parser_t::preorder_predicate_t" ref="af45b9d777cf02f50249b15f34999e444" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;bool (const <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a>&amp;)&gt; <a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00446">446</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06ef4f00c3f9746458bc8d84dafa2d9e"></a><!-- doxytag: member="adobe::xml_parser_t::token_type" ref="a06ef4f00c3f9746458bc8d84dafa2d9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef xml_lex_t::token_type <a class="el" href="classadobe_1_1xml__parser__t.html#a06ef4f00c3f9746458bc8d84dafa2d9e">token_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00447">447</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae609963b384cd8b4866118c240284e76"></a><!-- doxytag: member="adobe::xml_parser_t::xml_parser_t" ref="ae609963b384cd8b4866118c240284e76" args="(uchar_ptr_t first, uchar_ptr_t last, const line_position_t &amp;position, preorder_predicate_t predicate, callback_proc_t callback, O output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceadobe.html#a3e248dbe068eed9a0b0cae49818e935a">uchar_ptr_t</a>&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceadobe.html#a3e248dbe068eed9a0b0cae49818e935a">uchar_ptr_t</a>&#160;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1line__position__t.html">line_position_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a>&#160;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classadobe_1_1xml__parser__t.html#af3687fd97ef68e193747371a37679100">callback_proc_t</a>&#160;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"> <em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00449">449</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2ccb6d7cf2d0dad6fbb6519ce99d6a3"></a><!-- doxytag: member="adobe::xml_parser_t::xml_parser_t" ref="ab2ccb6d7cf2d0dad6fbb6519ce99d6a3" args="(const xml_parser_t &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&lt; O &gt; &amp;&#160;</td>
          <td class="paramname"> <em>rhs</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00462">462</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b6fc2a745d0ac3e55979ae19fcfd03b"></a><!-- doxytag: member="adobe::xml_parser_t::~xml_parser_t" ref="a8b6fc2a745d0ac3e55979ae19fcfd03b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00481">481</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7ea3234a5321799caddc563d09673ca3"></a><!-- doxytag: member="adobe::xml_parser_t::content_callback" ref="a7ea3234a5321799caddc563d09673ca3" args="(token_range_t &amp;result_element, const token_range_t &amp;old_element, const token_range_t &amp;start_tag, const attribute_set_t attribute_set, const token_range_t &amp;content, bool preorder_parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void content_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>result_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>old_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>start_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a>&#160;</td>
          <td class="paramname"> <em>attribute_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>preorder_parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00735">735</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a516db249450812f76e274e9ba8f2b998"></a><!-- doxytag: member="adobe::xml_parser_t::get_token" ref="a516db249450812f76e274e9ba8f2b998" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classadobe_1_1xml__parser__t.html#a06ef4f00c3f9746458bc8d84dafa2d9e">token_type</a>&amp; get_token </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00578">578</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9f948a5329c85aa7861a90c05583fd4"></a><!-- doxytag: member="adobe::xml_parser_t::is_attribute" ref="ab9f948a5329c85aa7861a90c05583fd4" args="(token_range_t &amp;name, token_range_t &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01130">1130</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac56ad6e038e9eb8b568716665151f718"></a><!-- doxytag: member="adobe::xml_parser_t::is_attribute_set" ref="ac56ad6e038e9eb8b568716665151f718" args="(attribute_set_t &amp;attribute_set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_attribute_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadobe_1_1attribute__set__t.html">attribute_set_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>attribute_set</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01033">1033</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82346a4fbf835f6927443820de3780d7"></a><!-- doxytag: member="adobe::xml_parser_t::is_bom" ref="a82346a4fbf835f6927443820de3780d7" args="(token_range_t &amp;bom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_bom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>bom</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01071">1071</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5307e252a6daacf7e0a82b93bd5d0a07"></a><!-- doxytag: member="adobe::xml_parser_t::is_content" ref="a5307e252a6daacf7e0a82b93bd5d0a07" args="(token_range_t &amp;element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_content </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>element</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00908">908</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee8b370eb2b72e3e5ee03ad5786e9142"></a><!-- doxytag: member="adobe::xml_parser_t::is_e_tag" ref="aee8b370eb2b72e3e5ee03ad5786e9142" args="(token_range_t &amp;name, token_range_t &amp;close_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_e_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>close_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01019">1019</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cce5ff4ee09280d67a50dcb6d9b22a1"></a><!-- doxytag: member="adobe::xml_parser_t::is_element" ref="a9cce5ff4ee09280d67a50dcb6d9b22a1" args="(token_range_t &amp;element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>element</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00788">788</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abff29ba11ce089101b78d16455547d46"></a><!-- doxytag: member="adobe::xml_parser_t::is_prolog" ref="abff29ba11ce089101b78d16455547d46" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_prolog </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01047">1047</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ed5db8e91ae9976c65716f7f7d71edf"></a><!-- doxytag: member="adobe::xml_parser_t::is_token" ref="a4ed5db8e91ae9976c65716f7f7d71edf" args="(xml_lex_token_set_t name, token_range_t &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_token </td>
          <td>(</td>
          <td class="paramtype">xml_lex_token_set_t&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00677">677</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb9bdc1714f2815fbca99a63c40cff27"></a><!-- doxytag: member="adobe::xml_parser_t::is_token" ref="afb9bdc1714f2815fbca99a63c40cff27" args="(xml_lex_token_set_t name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_token </td>
          <td>(</td>
          <td class="paramtype">xml_lex_token_set_t&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00696">696</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5c6570aa6ed80e4d7c228af88829c42"></a><!-- doxytag: member="adobe::xml_parser_t::is_xml_decl" ref="ac5c6570aa6ed80e4d7c228af88829c42" args="(token_range_t &amp;xml_decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_xml_decl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>xml_decl</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01114">1114</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88fa51c35dd13a7c4845fbbf2c0243b2"></a><!-- doxytag: member="adobe::xml_parser_t::next_position" ref="a88fa51c35dd13a7c4845fbbf2c0243b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structadobe_1_1line__position__t.html">line_position_t</a>&amp; next_position </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00484">484</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb7b7cbfd11211cd642b67cc646968bc"></a><!-- doxytag: member="adobe::xml_parser_t::operator=" ref="adb7b7cbfd11211cd642b67cc646968bc" args="(const xml_parser_t &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&lt; O &gt; &amp;&#160;</td>
          <td class="paramname"> <em>rhs</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00470">470</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08fb1267061b939749eb6a801949fed3"></a><!-- doxytag: member="adobe::xml_parser_t::parse_content" ref="a08fb1267061b939749eb6a801949fed3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parse_content </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parses the content range as the content of an xml element. </p>
<dl class="user"><dt><b></b></dt><dd>This function is most useful when invoking a sub-parser within an application's content callback function.</dd></dl>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Consider this document: <div class="fragment"><pre class="fragment">
&lt;?xml encoding="UTF-8" version="1.0" ?&gt;
&lt;root&gt;
    &lt;content&gt;sample document content&lt;/content&gt;
&lt;/root&gt;</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An application that wished to enforce the string structure of the document could use a content callback like the following to ensure that the root element of the document is "root", while also processing the content of the root element. <div class="fragment"><pre class="fragment"><a class="code" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0" title="A range of pointers denoting a token within a character stream.">token_range_t</a> top_level_callback(
                                  <span class="keyword">const</span> <a class="code" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0" title="A range of pointers denoting a token within a character stream.">token_range_t</a>&amp;     entire_element_range,
                                  <span class="keyword">const</span> <a class="code" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0" title="A range of pointers denoting a token within a character stream.">token_range_t</a>&amp;     name,
                                  <span class="keyword">const</span> attribute_set_t&amp;   attribute_set,
                                  <span class="keyword">const</span> <a class="code" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0" title="A range of pointers denoting a token within a character stream.">token_range_t</a>&amp;     value)
{
    assert(<a class="code" href="group__asl__xml__parser.html#ga82b556bd1c7fb00d02e52a530891f532">token_range_equal</a>(name, <a class="code" href="group__asl__xml__parser.html#gaba579cabc3da4495cf3ebcb7b4d77555">static_token_range</a>(<span class="stringliteral">&quot;root&quot;</span>)));
    
    <a class="code" href="classadobe_1_1xml__parser__t.html#aeed931c491ff72010b3e25cc444d0027" title="Create an object that will parse the indicated content range using the preorder and content functions...">make_xml_parser</a>(value.first, value.second,
                           line_position_t(<span class="stringliteral">&quot;top_level_callback&quot;</span>),
                           always_true&lt;token_range_t&gt;(),
                           root_callback,
                           null_output_t())
        .parse_content();
    
    <span class="keywordflow">return</span> <a class="code" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0" title="A range of pointers denoting a token within a character stream.">token_range_t</a>();
}
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, the top level callback performs a sanity check that the element it encounters is the tag "root". It then creates a new parser to process the content of the root element. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A less strict application could choose to use a single callback function for all elements or annotate a more complex data structure as the document is processed. </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01162">1162</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98c8def6deb836dad9a5e7a7da340a9c"></a><!-- doxytag: member="adobe::xml_parser_t::parse_document" ref="a98c8def6deb836dad9a5e7a7da340a9c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parse_document </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parses the content range as a well-formed xml document. </p>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01190">1190</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a60f66f94c6d678bc403ef8785ccf2e"></a><!-- doxytag: member="adobe::xml_parser_t::parse_element_sequence" ref="a8a60f66f94c6d678bc403ef8785ccf2e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parse_element_sequence </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parses the content range as a sequence of xml elements. Each element encountered in the content range is processed by the application. Character data between top-level elements in the content range is ignored by the parser and is not processed.</p>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Consider this content range: <div class="fragment"><pre class="fragment">
&lt;top-level type="simple"&gt;element 1&lt;/top-level&gt;

these characters are ignored

&lt;top-level type="complex"&gt;element 2&lt;embedded/&gt;&lt;/top-level&gt;</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Parsing this content range as an element sequence yields two top-level elements, one of which contains embedded elements. Each top-level element is processed by the application according to the application's preorder predicate and content callback functions. The content between the two top-level elements is ignored. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Element sequences can be useful for preference sets or other simple data that do not need significant structure (e.g. as a full document would contain). </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01147">1147</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a968822d98a344ef6aeb0bbcd36c1a66f"></a><!-- doxytag: member="adobe::xml_parser_t::putback" ref="a968822d98a344ef6aeb0bbcd36c1a66f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void putback </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00580">580</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa961c015d3eab65d0c27dc010b5e5ef2"></a><!-- doxytag: member="adobe::xml_parser_t::require_token" ref="aa961c015d3eab65d0c27dc010b5e5ef2" args="(xml_lex_token_set_t name, token_range_t &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void require_token </td>
          <td>(</td>
          <td class="paramtype">xml_lex_token_set_t&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__asl__xml__parser.html#ga9b424ac3bac58555445d796373c867b0">token_range_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00711">711</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5ce0a477296b065be7f3e0b3ddc6d05"></a><!-- doxytag: member="adobe::xml_parser_t::require_token" ref="aa5ce0a477296b065be7f3e0b3ddc6d05" args="(xml_lex_token_set_t name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void require_token </td>
          <td>(</td>
          <td class="paramtype">xml_lex_token_set_t&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00724">724</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4c20e9594632892ecd3e35b7368a4a7"></a><!-- doxytag: member="adobe::xml_parser_t::set_preorder_predicate" ref="ae4c20e9594632892ecd3e35b7368a4a7" args="(preorder_predicate_t pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_preorder_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a>&#160;</td>
          <td class="paramname"> <em>pred</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the client to specify a different preorder predicate after object instantiation</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate that indicates whether the client wants a given element to be parsed pre-order or in-order </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00492">492</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e5f6ac60026994518b28d0226e7666e"></a><!-- doxytag: member="adobe::xml_parser_t::throw_exception" ref="a3e5f6ac60026994518b28d0226e7666e" args="(xml_lex_token_set_t found, xml_lex_token_set_t expected)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void throw_exception </td>
          <td>(</td>
          <td class="paramtype">xml_lex_token_set_t&#160;</td>
          <td class="paramname"> <em>found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xml_lex_token_set_t&#160;</td>
          <td class="paramname"> <em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00592">592</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe0c1f897ab0fa4d49f228af8d32fbd9"></a><!-- doxytag: member="adobe::xml_parser_t::throw_exception" ref="abe0c1f897ab0fa4d49f228af8d32fbd9" args="(const char *error_string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void throw_exception </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>error_string</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00590">590</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aeed931c491ff72010b3e25cc444d0027"></a><!-- doxytag: member="adobe::xml_parser_t::make_xml_parser" ref="aeed931c491ff72010b3e25cc444d0027" args="(uchar_ptr_t first, uchar_ptr_t last, const line_position_t &amp;position, typename xml_parser_t&lt; O &gt;::preorder_predicate_t predicate, typename xml_parser_t&lt; O &gt;::callback_proc_t callback, O output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&lt; O &gt; make_xml_parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceadobe.html#a3e248dbe068eed9a0b0cae49818e935a">uchar_ptr_t</a>&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceadobe.html#a3e248dbe068eed9a0b0cae49818e935a">uchar_ptr_t</a>&#160;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structadobe_1_1line__position__t.html">line_position_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&lt; O &gt;::<a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a>&#160;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classadobe_1_1xml__parser__t.html">xml_parser_t</a>&lt; O &gt;::<a class="el" href="classadobe_1_1xml__parser__t.html#af3687fd97ef68e193747371a37679100">callback_proc_t</a>&#160;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"> <em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an object that will parse the indicated content range using the preorder and content functions indicated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>the start of the content range (analagous to a begin iterator) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>the end of the content range (analagous to an end iterator) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>an annotation of the line number at which then content range begins. Used when errors are encountered while parsing the content range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td>a predicate that indicates whether the application's content callback will be called pre-order or in-order for a given element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>the applications content callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>an object that models OutputIterator to which the parser will insert the result of processing the content range</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an xml parser object that will process the indicated content range using the indicated application callbacks </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l01222">1222</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ab8baf66bcc875d9acc8a28f2665a79d2"></a><!-- doxytag: member="adobe::xml_parser_t::callback_m" ref="ab8baf66bcc875d9acc8a28f2665a79d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classadobe_1_1xml__parser__t.html#af3687fd97ef68e193747371a37679100">callback_proc_t</a> <a class="el" href="classadobe_1_1xml__parser__t.html#ab8baf66bcc875d9acc8a28f2665a79d2">callback_m</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00612">612</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85d84ef7746b33dd4e0fe2edcb07506f"></a><!-- doxytag: member="adobe::xml_parser_t::output_m" ref="a85d84ef7746b33dd4e0fe2edcb07506f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O <a class="el" href="classadobe_1_1xml__parser__t.html#a85d84ef7746b33dd4e0fe2edcb07506f">output_m</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00613">613</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee18efd3107beea00b9faea41e55ff3b"></a><!-- doxytag: member="adobe::xml_parser_t::pred_m" ref="aee18efd3107beea00b9faea41e55ff3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classadobe_1_1xml__parser__t.html#af45b9d777cf02f50249b15f34999e444">preorder_predicate_t</a> <a class="el" href="classadobe_1_1xml__parser__t.html#aee18efd3107beea00b9faea41e55ff3b">pred_m</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00611">611</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
